/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "XuHuaian,s Blog",
  "description": "记录自己的工作学习心得，争取当一条有梦想的咸鱼",
  "base": "/",
  "headTags": [
    [
      "link",
      {
        "rel": "icon",
        "href": "/images/logo1.png"
      }
    ],
    [
      "meta",
      {
        "name": "theme-color",
        "content": "#11a8cd"
      }
    ],
    [
      "meta",
      {
        "name": "referrer",
        "content": "no-referrer-when-downgrade"
      }
    ],
    [
      "link",
      {
        "rel": "stylesheet",
        "href": "https://at.alicdn.com/t/font_1678482_4tbhmh589x.css"
      }
    ]
  ],
  "pages": [
    {
      "title": "分类",
      "frontmatter": {
        "categoriesPage": true,
        "title": "分类",
        "permalink": "/categories/",
        "article": false
      },
      "regularPath": "/@pages/categoriesPage.html",
      "relativePath": "@pages/categoriesPage.md",
      "key": "v-0c322e48",
      "path": "/categories/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/01/29, 20:04:55",
      "lastUpdatedTimestamp": 1643457895000
    },
    {
      "title": "RPC",
      "frontmatter": {
        "title": "RPC",
        "date": "2022-01-10T21:59:38.000Z",
        "permalink": "/pages/52d5c3",
        "article": "auto",
        "categories": [
          "gRPC笔记"
        ],
        "tags": [
          "gRPC",
          "Java"
        ]
      },
      "regularPath": "/Java/01.gRPC%E7%AC%94%E8%AE%B0/01.RPC.html",
      "relativePath": "Java/01.gRPC笔记/01.RPC.md",
      "key": "v-a2c1f742",
      "path": "/pages/52d5c3/",
      "headers": [
        {
          "level": 2,
          "title": "1.1 RPC是啥",
          "slug": "_1-1-rpc是啥",
          "normalizedTitle": "1.1 rpc是啥",
          "charIndex": 13
        },
        {
          "level": 2,
          "title": "1.2 RPC 框架",
          "slug": "_1-2-rpc-框架",
          "normalizedTitle": "1.2 rpc 框架",
          "charIndex": 243
        },
        {
          "level": 3,
          "title": "1.2.1 服务治理（SOA）",
          "slug": "_1-2-1-服务治理-soa",
          "normalizedTitle": "1.2.1 服务治理（soa）",
          "charIndex": 592
        },
        {
          "level": 2,
          "title": "1.3 RPC vs HTTP Service",
          "slug": "_1-3-rpc-vs-http-service",
          "normalizedTitle": "1.3 rpc vs http service",
          "charIndex": 703
        },
        {
          "level": 2,
          "title": "1.4 HTTP/2 协议",
          "slug": "_1-4-http-2-协议",
          "normalizedTitle": "1.4 http/2 协议",
          "charIndex": 1286
        },
        {
          "level": 3,
          "title": "1.4.1 HTTP 发展历史",
          "slug": "_1-4-1-http-发展历史",
          "normalizedTitle": "1.4.1 http 发展历史",
          "charIndex": 1359
        },
        {
          "level": 3,
          "title": "1.4.2 HTTP/2.0 新特性",
          "slug": "_1-4-2-http-2-0-新特性",
          "normalizedTitle": "1.4.2 http/2.0 新特性",
          "charIndex": 1559
        },
        {
          "level": 2,
          "title": "参考链接",
          "slug": "参考链接",
          "normalizedTitle": "参考链接",
          "charIndex": 2404
        }
      ],
      "headersStr": "1.1 RPC是啥 1.2 RPC 框架 1.2.1 服务治理（SOA） 1.3 RPC vs HTTP Service 1.4 HTTP/2 协议 1.4.1 HTTP 发展历史 1.4.2 HTTP/2.0 新特性 参考链接",
      "content": "# 一、背景知识\n\n\n# 1.1 RPC是啥\n\n    RPC (Remote Procedure Calls) 远程过程调用。本地调用远程方法，比较直接的做法是服务端暴露出 Restful 接口，客户端发 http request 去调用，RPC 的过程简单来看可以理解成是对这个操作进行的一层封装。 RPC 调用过程如下图所示，RPC 对服务调用方屏蔽掉网络请求、消息编码、数据传输等工作，提供一个代理对象给调用方，使服务调用方调用远程方法时如同调用本地方法一样简洁。\n\n\n\n\n# 1.2 RPC 框架\n\n    RPC 抽象来看可以归纳为两方面问题： 1.调用方与提供方协议约定问题； 2.网络传输问题 ，解决这两块基本问题后，还得需要工程落地，解决服务发现、负载均衡、限流熔断等等问题，于是有了 RPC 框架的出现。\n\n\n\n上图是一个典型的 RPC 框架的基本架构，主要分成四块：\n\n>  * 入口层：动态代理机制在服务提供方包装好服务的接口，暴露给调用方；对调用方提供代理对象，屏蔽其感知远程过程调用；\n> \n>  * 集群层：解决分布式场景下的服务发现、节点负载均衡、容错、路由管理等等问题；\n> \n>  * 协议层: 约定调用方与提供方数据包的格式，提供反序列化、解压缩等功能支持；\n> \n>  * 网络传输: 提供 TCP 长链接传输、HTTP 通信等功能。\n\n\n# 1.2.1 服务治理（SOA）\n\n服务治理解决什么问题？\n\n\n\n * 服务发现机制\n\n\n\n类似 DNS 的机制，服务提供方向注册中心进行注册，调用方订阅服注册中心；注册中心拿到当前提供方服务的地址后推送给调用方。\n\n\n# 1.3 RPC vs HTTP Service\n\n相比于 HTTP 服务，RPC 具有以下优势：\n\n * 网络传输方面：基于 TCP 长链接，省去了 HTTP 连接建立过程中的性能损耗，提高传输效率；\n * 传输消息方面：传输的消息序列化成二进制对象，数据包体积减小，节省带宽；\n * 开发者友好：RPC 牺牲了消息的可读性来提高易用性，对于调用方开发者只需要调用本地接口即可调用远程方法；\n * 面向服务的封装：成熟的 RPC 框架封装了服务发现、负载均衡、熔断降级等等面向服务的高级特性，单纯使用 HTTP 服务调用则少了这些特性。\n\n同时，也存在一些劣势：\n\n * 数据包可读性差，提高团队成员学习成本；\n * 交互性单一：只能调用方主动调用服务端方法，在需要服务端下发通知等场景下不适用。\n\n如何选择 RPC 或 HTTP 服务？\n\n 1. 公司内部给其他业务提供接口时，优先考虑 RPC 服务，使用方为公司外部的服务，优先考虑 HTTP 服务；\n 2. 对于消耗特定资源的（例如 GPU/CPU/大内存资源），有特殊依赖的（比如运行环境需要依赖外部的 ffmpeg），集中实现效率比较高的（比如某个业务集中到几台机器，可以使用大内存缓存等）,选 RPC；\n 3. 一些经常变化的业务逻辑，依赖很广泛，又需要实现可以收敛且能随时更新，选择 RPC。\n\n\n# 1.4 HTTP/2 协议\n\ngRPC 框架的网络传输部分依赖 HTTP/2 协议，为理解 gRPC，先来了解一下 HTTP/2 协议。\n\n\n# 1.4.1 HTTP 发展历史\n\n * HTTP/1.0：链接无法复用，每次请求都需要经过三次握手，重新建立连接，增加延迟；\n * HTTP/1.1：Headers 中增加keep-alive 标识，可以复用一部分连接，但域名分片等情况下，仍需要建立多次连接，耗费资源；\n * HTTP/2.0：为提高传输性能，HTTP/2.0 在客户端和服务端之间只建立一个链接(connection)。\n\n\n# 1.4.2 HTTP/2.0 新特性\n\nHTTP/2.0 协议 2015 年发布，完整的升级涉及到的内容较多，这里只挑部分特性了解一下。\n\n * 基本概念\n\n>  * 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符；\n> \n>  * 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成；\n> \n>  * 帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等\n\n * 二进制传输消息\n\nHTTP/1.x 的请求包和响应包，都是由起始行、Headers 和 Body 组成，各部分之间以文本换行符分隔，而 HTTP/2 将请求和响应数据分割为更小的帧，并且采用二进制编码 。\n\n * 多路复用\n\n针对同一域名只建立一个链接(Connection)，该信道可承载任意数量的双向数据流(Stream)，每个数据流中以消息(Message)的形式读写，一个消息的最小组成单位为帧(Frame)，数据流内的消息可以乱序发送，根据帧头部的流标识可以重排。\n\n\n\n * Header 压缩\n\n在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。\n\n为了减少这块的资源消耗并提升性能， HTTP/2对这些首部采取了压缩策略：\n\n>  * HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；\n> \n>  * 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;\n> \n>  * 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。\n\n例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。\n\n\n\n\n# 参考链接\n\ngRPC系列(三) 如何借助HTTP2实现传输\n深入理解Protobuf3协议原理\n\n> 本文作者：许怀安\n> 创作时间：2022.1.10\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# 一、背景知识\n\n\n# 1.1 rpc是啥\n\n    rpc (remote procedure calls) 远程过程调用。本地调用远程方法，比较直接的做法是服务端暴露出 restful 接口，客户端发 http request 去调用，rpc 的过程简单来看可以理解成是对这个操作进行的一层封装。 rpc 调用过程如下图所示，rpc 对服务调用方屏蔽掉网络请求、消息编码、数据传输等工作，提供一个代理对象给调用方，使服务调用方调用远程方法时如同调用本地方法一样简洁。\n\n\n\n\n# 1.2 rpc 框架\n\n    rpc 抽象来看可以归纳为两方面问题： 1.调用方与提供方协议约定问题； 2.网络传输问题 ，解决这两块基本问题后，还得需要工程落地，解决服务发现、负载均衡、限流熔断等等问题，于是有了 rpc 框架的出现。\n\n\n\n上图是一个典型的 rpc 框架的基本架构，主要分成四块：\n\n>  * 入口层：动态代理机制在服务提供方包装好服务的接口，暴露给调用方；对调用方提供代理对象，屏蔽其感知远程过程调用；\n> \n>  * 集群层：解决分布式场景下的服务发现、节点负载均衡、容错、路由管理等等问题；\n> \n>  * 协议层: 约定调用方与提供方数据包的格式，提供反序列化、解压缩等功能支持；\n> \n>  * 网络传输: 提供 tcp 长链接传输、http 通信等功能。\n\n\n# 1.2.1 服务治理（soa）\n\n服务治理解决什么问题？\n\n\n\n * 服务发现机制\n\n\n\n类似 dns 的机制，服务提供方向注册中心进行注册，调用方订阅服注册中心；注册中心拿到当前提供方服务的地址后推送给调用方。\n\n\n# 1.3 rpc vs http service\n\n相比于 http 服务，rpc 具有以下优势：\n\n * 网络传输方面：基于 tcp 长链接，省去了 http 连接建立过程中的性能损耗，提高传输效率；\n * 传输消息方面：传输的消息序列化成二进制对象，数据包体积减小，节省带宽；\n * 开发者友好：rpc 牺牲了消息的可读性来提高易用性，对于调用方开发者只需要调用本地接口即可调用远程方法；\n * 面向服务的封装：成熟的 rpc 框架封装了服务发现、负载均衡、熔断降级等等面向服务的高级特性，单纯使用 http 服务调用则少了这些特性。\n\n同时，也存在一些劣势：\n\n * 数据包可读性差，提高团队成员学习成本；\n * 交互性单一：只能调用方主动调用服务端方法，在需要服务端下发通知等场景下不适用。\n\n如何选择 rpc 或 http 服务？\n\n 1. 公司内部给其他业务提供接口时，优先考虑 rpc 服务，使用方为公司外部的服务，优先考虑 http 服务；\n 2. 对于消耗特定资源的（例如 gpu/cpu/大内存资源），有特殊依赖的（比如运行环境需要依赖外部的 ffmpeg），集中实现效率比较高的（比如某个业务集中到几台机器，可以使用大内存缓存等）,选 rpc；\n 3. 一些经常变化的业务逻辑，依赖很广泛，又需要实现可以收敛且能随时更新，选择 rpc。\n\n\n# 1.4 http/2 协议\n\ngrpc 框架的网络传输部分依赖 http/2 协议，为理解 grpc，先来了解一下 http/2 协议。\n\n\n# 1.4.1 http 发展历史\n\n * http/1.0：链接无法复用，每次请求都需要经过三次握手，重新建立连接，增加延迟；\n * http/1.1：headers 中增加keep-alive 标识，可以复用一部分连接，但域名分片等情况下，仍需要建立多次连接，耗费资源；\n * http/2.0：为提高传输性能，http/2.0 在客户端和服务端之间只建立一个链接(connection)。\n\n\n# 1.4.2 http/2.0 新特性\n\nhttp/2.0 协议 2015 年发布，完整的升级涉及到的内容较多，这里只挑部分特性了解一下。\n\n * 基本概念\n\n>  * 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符；\n> \n>  * 消息：是指逻辑上的 http 消息，比如请求、响应等，由一或多个帧组成；\n> \n>  * 帧：http 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 http 首部、负荷，等等\n\n * 二进制传输消息\n\nhttp/1.x 的请求包和响应包，都是由起始行、headers 和 body 组成，各部分之间以文本换行符分隔，而 http/2 将请求和响应数据分割为更小的帧，并且采用二进制编码 。\n\n * 多路复用\n\n针对同一域名只建立一个链接(connection)，该信道可承载任意数量的双向数据流(stream)，每个数据流中以消息(message)的形式读写，一个消息的最小组成单位为帧(frame)，数据流内的消息可以乱序发送，根据帧头部的流标识可以重排。\n\n\n\n * header 压缩\n\n在 http/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。\n\n为了减少这块的资源消耗并提升性能， http/2对这些首部采取了压缩策略：\n\n>  * http/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；\n> \n>  * 首部表在http/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;\n> \n>  * 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。\n\n例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。\n\n\n\n\n# 参考链接\n\ngrpc系列(三) 如何借助http2实现传输\n深入理解protobuf3协议原理\n\n> 本文作者：许怀安\n> 创作时间：2022.1.10\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/10, 11:28:11",
      "lastUpdatedTimestamp": 1646882891000
    },
    {
      "title": "标签",
      "frontmatter": {
        "tagsPage": true,
        "title": "标签",
        "permalink": "/tags/",
        "article": false
      },
      "regularPath": "/@pages/tagsPage.html",
      "relativePath": "@pages/tagsPage.md",
      "key": "v-6f0b6508",
      "path": "/tags/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/01/29, 20:04:55",
      "lastUpdatedTimestamp": 1643457895000
    },
    {
      "title": "gRPC框架",
      "frontmatter": {
        "title": "gRPC框架",
        "date": "2022-01-10T21:59:38.000Z",
        "permalink": "/pages/a2f161",
        "article": "auto",
        "categories": [
          "gRPC笔记"
        ],
        "tags": [
          "gRPC",
          "Java"
        ]
      },
      "regularPath": "/Java/01.gRPC%E7%AC%94%E8%AE%B0/02.gRPC%E6%A1%86%E6%9E%B6.html",
      "relativePath": "Java/01.gRPC笔记/02.gRPC框架.md",
      "key": "v-ceab546a",
      "path": "/pages/a2f161/",
      "headers": [
        {
          "level": 2,
          "title": "2.1 gRPC 特性",
          "slug": "_2-1-grpc-特性",
          "normalizedTitle": "2.1 grpc 特性",
          "charIndex": 13
        },
        {
          "level": 2,
          "title": "2.2 gRPC 核心概念",
          "slug": "_2-2-grpc-核心概念",
          "normalizedTitle": "2.2 grpc 核心概念",
          "charIndex": 354
        },
        {
          "level": 3,
          "title": "2.2.1 服务调用模式",
          "slug": "_2-2-1-服务调用模式",
          "normalizedTitle": "2.2.1 服务调用模式",
          "charIndex": 372
        },
        {
          "level": 3,
          "title": "2.2.2 Protobuf",
          "slug": "_2-2-2-protobuf",
          "normalizedTitle": "2.2.2 protobuf",
          "charIndex": 1046
        },
        {
          "level": 2,
          "title": "参考链接",
          "slug": "参考链接",
          "normalizedTitle": "参考链接",
          "charIndex": 2456
        }
      ],
      "headersStr": "2.1 gRPC 特性 2.2 gRPC 核心概念 2.2.1 服务调用模式 2.2.2 Protobuf 参考链接",
      "content": "# 二、gRPC\n\n\n# 2.1 gRPC 特性\n\n * 优势\n\n>  * 支持多种语言；\n> \n>  * 基于 IDL 文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub；\n> \n>  * 网络通信依赖 Netty 实现的 HTTP/2 协议封装，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量；\n> \n>  * 序列化支持 PB（Protocol Buffer）和 JSON，PB 是一种语言无关的高性能序列化框架，基于 HTTP/2 + PB, 保障了 RPC 调用的高性能。\n\n * 劣势\n\n>  * 服务治理相关能力缺失，负载均衡和服务发现等功能需要开发者扩展实现。\n\n\n# 2.2 gRPC 核心概念\n\n\n# 2.2.1 服务调用模式\n\n    gRPC 底层通信依赖于 HTTP/2 协议，由于 HTTP/2 协议是一个支持双向流的协议，因此 gRPC 在 API 的设计上也才用了流的方式。gRPC 中允许定义四种服务调用模式：\n\n 1. Unary 调用模式：响应-请求模式，客户端发送请求给服务端，服务端应答；\n\n示例\n\nrpc SayHello(HelloRequest) returns (HelloResponse){ }\n\n 2. Server Streaming 模式：客户端发送一个请求给服务端，并获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止；\n\n示例\n\nrpc LotsOfReplies(HelloRequest) returns (stream HelloResponse){ }\n\n 3. Client Streaming 模式：客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答；\n\n示例\n\nrpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) { }\n\n 4. 双向 Streaming 模式：通信双方之间建立相互独立的读写数据流来发送一系列消息，双方都可发送多次消息，且允许乱序发送消息。\n\n示例\n\nrpc BidiHello(stream HelloRequest) returns (stream HelloResponse){ }\n\n\n# 2.2.2 Protobuf\n\n    gRPC 默认使用 Protocol Buffers (Protobuf) 作为接口定义语言，来描述服务接口和消息结构。Protocol Buffers 是一个可独立使用的序列化框架，它并不与 gRPC 框架绑定，任何需要支持多语言的 RPC 框架都可以选择使用 Protocol Buffers 作为序列化框架。\n\nProtocol Buffers 的使用主要包括:\n\n>  * IDL 文件定义（*.proto）, 包含数据结构定义，以及可选的服务接口定义（gRPC）；\n> \n>  * 各种语言的代码生成（含数据结构定义、以及序列化和反序列化接口）；\n> \n>  * 使用 Protocol Buffers 的 API 进行序列化和反序列化。\n\n# 支持的数据结构\n\n * 支持主流语言常用数据结构，考虑到跨语言特性，对于特定语言的数据结构并不提供支持，如 Java 的 Exception 对象。\n\n# 基本数据类型\n\nPROTOBUF   C++      JAVA\ndouble     double   double\nfloat      float    float\nint32      int32    int\nint64      int64    long\nstring     string   String\nbytes      string   ByteString\nbool       bool     boolean\n…          …        …\n\n表1. Protobuf 基本数据类型对照表\n\n# 复杂数据类型\n\n * 数组类型\n\n利用 Protobuf 提供的 repeted关键字，标识该字段重复任意次数，相当于数组的功能。\n\n * 枚举类型\n\nenum关键字定义枚举类型，eg.\n\nmessage QueryInfo{\n\tstring queryID = 1;\n\tenum Types{\n\t\tUSER = 0;\n\t\tGROUP=1;\n\t\tOTHERS=2;\n\t}\n\tTypes type = 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * Map 类型\n\n在 Protobuf 3 中新增了对 Map 类型的支持，eg.\n\nmap<key_type, value_type> map_field = N;\nmessage ValueType{...}\nmap<string, ValueType> typeMap = 0;\n\n\n1\n2\n3\n\n * 泛型\n\n对于类型无法确定的情况，类似于 Java 中的泛型，Protobuf 提供了google.protobuf.Any这个类型，表示存放任意类型的数据。根据我司开发规范，这种类型被强制不允许使用。\n\n详细语法参考：Language Guide (proto3)\n\n# 代码生成\n\n.proto 文件中定义的每个 service ，protoc 会生成一个名为{service_name}Grpc的类，这个类存放在java_packag指定的包结构下。\n\n下载 protoc 后，可以通过命令行调用 protoc 来生成桩代码，或者使用官方推荐的更优雅的方式，配置 maven 或者 gradle 在项目编译时自动生成桩代码。maven 配置见下文。\n\n\n# 参考链接\n\ngRPC系列(三) 如何借助HTTP2实现传输\n深入理解Protobuf3协议原理\n\n> 本文作者：许怀安\n> 创作时间：2022.1.10\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# 二、grpc\n\n\n# 2.1 grpc 特性\n\n * 优势\n\n>  * 支持多种语言；\n> \n>  * 基于 idl 文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 stub；\n> \n>  * 网络通信依赖 netty 实现的 http/2 协议封装，支持双向流、消息头压缩、单 tcp 的多路复用、服务端推送等特性，这些特性使得 grpc 在移动端设备上更加省电和节省网络流量；\n> \n>  * 序列化支持 pb（protocol buffer）和 json，pb 是一种语言无关的高性能序列化框架，基于 http/2 + pb, 保障了 rpc 调用的高性能。\n\n * 劣势\n\n>  * 服务治理相关能力缺失，负载均衡和服务发现等功能需要开发者扩展实现。\n\n\n# 2.2 grpc 核心概念\n\n\n# 2.2.1 服务调用模式\n\n    grpc 底层通信依赖于 http/2 协议，由于 http/2 协议是一个支持双向流的协议，因此 grpc 在 api 的设计上也才用了流的方式。grpc 中允许定义四种服务调用模式：\n\n 1. unary 调用模式：响应-请求模式，客户端发送请求给服务端，服务端应答；\n\n示例\n\nrpc sayhello(hellorequest) returns (helloresponse){ }\n\n 2. server streaming 模式：客户端发送一个请求给服务端，并获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止；\n\n示例\n\nrpc lotsofreplies(hellorequest) returns (stream helloresponse){ }\n\n 3. client streaming 模式：客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答；\n\n示例\n\nrpc lotsofgreetings(stream hellorequest) returns (helloresponse) { }\n\n 4. 双向 streaming 模式：通信双方之间建立相互独立的读写数据流来发送一系列消息，双方都可发送多次消息，且允许乱序发送消息。\n\n示例\n\nrpc bidihello(stream hellorequest) returns (stream helloresponse){ }\n\n\n# 2.2.2 protobuf\n\n    grpc 默认使用 protocol buffers (protobuf) 作为接口定义语言，来描述服务接口和消息结构。protocol buffers 是一个可独立使用的序列化框架，它并不与 grpc 框架绑定，任何需要支持多语言的 rpc 框架都可以选择使用 protocol buffers 作为序列化框架。\n\nprotocol buffers 的使用主要包括:\n\n>  * idl 文件定义（*.proto）, 包含数据结构定义，以及可选的服务接口定义（grpc）；\n> \n>  * 各种语言的代码生成（含数据结构定义、以及序列化和反序列化接口）；\n> \n>  * 使用 protocol buffers 的 api 进行序列化和反序列化。\n\n# 支持的数据结构\n\n * 支持主流语言常用数据结构，考虑到跨语言特性，对于特定语言的数据结构并不提供支持，如 java 的 exception 对象。\n\n# 基本数据类型\n\nprotobuf   c++      java\ndouble     double   double\nfloat      float    float\nint32      int32    int\nint64      int64    long\nstring     string   string\nbytes      string   bytestring\nbool       bool     boolean\n…          …        …\n\n表1. protobuf 基本数据类型对照表\n\n# 复杂数据类型\n\n * 数组类型\n\n利用 protobuf 提供的 repeted关键字，标识该字段重复任意次数，相当于数组的功能。\n\n * 枚举类型\n\nenum关键字定义枚举类型，eg.\n\nmessage queryinfo{\n\tstring queryid = 1;\n\tenum types{\n\t\tuser = 0;\n\t\tgroup=1;\n\t\tothers=2;\n\t}\n\ttypes type = 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * map 类型\n\n在 protobuf 3 中新增了对 map 类型的支持，eg.\n\nmap<key_type, value_type> map_field = n;\nmessage valuetype{...}\nmap<string, valuetype> typemap = 0;\n\n\n1\n2\n3\n\n * 泛型\n\n对于类型无法确定的情况，类似于 java 中的泛型，protobuf 提供了google.protobuf.any这个类型，表示存放任意类型的数据。根据我司开发规范，这种类型被强制不允许使用。\n\n详细语法参考：language guide (proto3)\n\n# 代码生成\n\n.proto 文件中定义的每个 service ，protoc 会生成一个名为{service_name}grpc的类，这个类存放在java_packag指定的包结构下。\n\n下载 protoc 后，可以通过命令行调用 protoc 来生成桩代码，或者使用官方推荐的更优雅的方式，配置 maven 或者 gradle 在项目编译时自动生成桩代码。maven 配置见下文。\n\n\n# 参考链接\n\ngrpc系列(三) 如何借助http2实现传输\n深入理解protobuf3协议原理\n\n> 本文作者：许怀安\n> 创作时间：2022.1.10\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/10, 11:28:11",
      "lastUpdatedTimestamp": 1646882891000
    },
    {
      "title": "gRPC Bug记录",
      "frontmatter": {
        "title": "gRPC Bug记录",
        "date": "2021-01-10T21:59:38.000Z",
        "permalink": "/pages/2f674a",
        "article": "auto",
        "categories": [
          "gRPC笔记"
        ],
        "tags": [
          "gRPC",
          "Java"
        ]
      },
      "regularPath": "/Java/01.gRPC%E7%AC%94%E8%AE%B0/04.gRPC_Bug.html",
      "relativePath": "Java/01.gRPC笔记/04.gRPC_Bug.md",
      "key": "v-51b302ef",
      "path": "/pages/2f674a/",
      "headers": [
        {
          "level": 2,
          "title": "4.1找不到类io.grpc.BindableService",
          "slug": "_4-1找不到类io-grpc-bindableservice",
          "normalizedTitle": "4.1找不到类io.grpc.bindableservice",
          "charIndex": 14
        },
        {
          "level": 2,
          "title": "参考链接",
          "slug": "参考链接",
          "normalizedTitle": "参考链接",
          "charIndex": 1138
        }
      ],
      "headersStr": "4.1找不到类io.grpc.BindableService 参考链接",
      "content": "# 四、Bug记录\n\n\n# 4.1找不到类io.grpc.BindableService\n\njava.lang.NoClassDefFoundError: io/grpc/BindableService\n\tat java.lang.Class.getDeclaredMethods0(Native Method)\n\tat java.lang.Class.privateGetDeclaredMethods(Class.java:2701)\n\tat java.lang.Class.privateGetMethodRecursive(Class.java:3048)\n\tat java.lang.Class.getMethod0(Class.java:3018)\n\tat java.lang.Class.getMethod(Class.java:1784)\n\tat sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)\n\tat sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)\nCaused by: java.lang.ClassNotFoundException: io.grpc.BindableService\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 7 more\nError: A JNI error has occurred, please check your installation and try again\nException in thread \"main\" \nProcess finished with exit code 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nTips\n\n原因：\njdk 版本和 jre 版本不一致引起该问题。\n\n解决：\n检查 java -version 和 javac -version 版本是否一致。\n\n\n\n重新安装一致的版本。\n\n\n# 参考链接\n\ngRPC系列(三) 如何借助HTTP2实现传输\n深入理解Protobuf3协议原理\n\n> 本文作者：许怀安\n> 创作时间：2022.1.10\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# 四、bug记录\n\n\n# 4.1找不到类io.grpc.bindableservice\n\njava.lang.noclassdeffounderror: io/grpc/bindableservice\n\tat java.lang.class.getdeclaredmethods0(native method)\n\tat java.lang.class.privategetdeclaredmethods(class.java:2701)\n\tat java.lang.class.privategetmethodrecursive(class.java:3048)\n\tat java.lang.class.getmethod0(class.java:3018)\n\tat java.lang.class.getmethod(class.java:1784)\n\tat sun.launcher.launcherhelper.validatemainclass(launcherhelper.java:544)\n\tat sun.launcher.launcherhelper.checkandloadmain(launcherhelper.java:526)\ncaused by: java.lang.classnotfoundexception: io.grpc.bindableservice\n\tat java.net.urlclassloader.findclass(urlclassloader.java:381)\n\tat java.lang.classloader.loadclass(classloader.java:424)\n\tat sun.misc.launcher$appclassloader.loadclass(launcher.java:349)\n\tat java.lang.classloader.loadclass(classloader.java:357)\n\t... 7 more\nerror: a jni error has occurred, please check your installation and try again\nexception in thread \"main\" \nprocess finished with exit code 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ntips\n\n原因：\njdk 版本和 jre 版本不一致引起该问题。\n\n解决：\n检查 java -version 和 javac -version 版本是否一致。\n\n\n\n重新安装一致的版本。\n\n\n# 参考链接\n\ngrpc系列(三) 如何借助http2实现传输\n深入理解protobuf3协议原理\n\n> 本文作者：许怀安\n> 创作时间：2022.1.10\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/10, 11:28:11",
      "lastUpdatedTimestamp": 1646882891000
    },
    {
      "title": "HuTool",
      "frontmatter": {
        "title": "HuTool",
        "date": "2022-01-26T20:56:49.000Z",
        "permalink": "/pages/5fedc1/",
        "categories": [
          "Java",
          "HuTool笔记"
        ],
        "tags": [
          "Java"
        ]
      },
      "regularPath": "/Java/02.HuTool%E7%AC%94%E8%AE%B0/01.HuTool.html",
      "relativePath": "Java/02.HuTool笔记/01.HuTool.md",
      "key": "v-31df7039",
      "path": "/pages/5fedc1/",
      "headers": [
        {
          "level": 2,
          "title": "1.1 简介",
          "slug": "_1-1-简介",
          "normalizedTitle": "1.1 简介",
          "charIndex": 21
        },
        {
          "level": 2,
          "title": "1.2 包含的组件",
          "slug": "_1-2-包含的组件",
          "normalizedTitle": "1.2 包含的组件",
          "charIndex": 278
        },
        {
          "level": 2,
          "title": "1.3 文档",
          "slug": "_1-3-文档",
          "normalizedTitle": "1.3 文档",
          "charIndex": 1240
        },
        {
          "level": 2,
          "title": "1.4 安装HuTool",
          "slug": "_1-4-安装hutool",
          "normalizedTitle": "1.4 安装hutool",
          "charIndex": 1264
        },
        {
          "level": 3,
          "title": "1.4.1 Maven",
          "slug": "_1-4-1-maven",
          "normalizedTitle": "1.4.1 maven",
          "charIndex": 1281
        },
        {
          "level": 3,
          "title": "1.4.2 下载jar包",
          "slug": "_1-4-2-下载jar包",
          "normalizedTitle": "1.4.2 下载jar包",
          "charIndex": 1441
        },
        {
          "level": 3,
          "title": "1.4.3 编译安装",
          "slug": "_1-4-3-编译安装",
          "normalizedTitle": "1.4.3 编译安装",
          "charIndex": 1590
        }
      ],
      "headersStr": "1.1 简介 1.2 包含的组件 1.3 文档 1.4 安装HuTool 1.4.1 Maven 1.4.2 下载jar包 1.4.3 编译安装",
      "content": "# 一、Hutool的入门与安装\n\n\n# 1.1 简介\n\nHutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以甜甜的。\n\nHutool中的工具方法来自每个用户的精雕细琢，它涵盖了Java开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；\n\nHutool是项目中util包友好的替代，它节省了开发人员对项目中公用类和公用工具方法的封装时间，使开发专注于业务，同时可以最大限度的避免封装不完善带来的bug。\n\n\n# 1.2 包含的组件\n\n一个Java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件：\n\n模块                   介绍\nhutool-aop           JDK动态代理封装，提供非IOC下的切面支持\nhutool-bloomFilter   布隆过滤，提供一些Hash算法的布隆过滤\nhutool-cache         简单缓存实现\nhutool-core          核心，包括Bean操作、日期、各种Util等\nhutool-cron          定时任务模块，提供类Crontab表达式的定时任务\nhutool-crypto        加密解密模块，提供对称、非对称和摘要算法封装\nhutool-db            JDBC封装后的数据操作，基于ActiveRecord思想\nhutool-dfa           基于DFA模型的多关键字查找\nhutool-extra         扩展模块，对第三方封装（模板引擎、邮件、Servlet、二维码、Emoji、FTP、分词等）\nhutool-http          基于HttpUrlConnection的Http客户端封装\nhutool-log           自动识别日志实现的日志门面\nhutool-script        脚本执行封装，例如Javascript\nhutool-setting       功能更强大的Setting配置文件和Properties封装\nhutool-system        系统参数调用封装（JVM信息等）\nhutool-json          JSON实现\nhutool-captcha       图片验证码实现\nhutool-poi           针对POI中Excel和Word的封装\nhutool-socket        基于Java的NIO和AIO的Socket封装\nhutool-jwt           JSON Web Token (JWT)封装实现\n\n可以根据需求对每个模块单独引入，也可以通过引入hutool-all方式引入所有模块。\n\n\n# 1.3 文档\n\n官方文档\n\n参考API\n\n\n# 1.4 安装HuTool\n\n\n# 1.4.1 Maven\n\n<dependency>\n    <groupId>cn.hutool</groupId>\n    <artifactId>hutool-all</artifactId>\n    <version>5.7.20</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 1.4.2 下载jar包\n\n通过Maven中央库下载 hutool-all-X.X.X.jar 即可\n\n小tips\n\nHutool 5.x支持JDK8+，对Android平台没有测试，不能保证所有工具类或工具方法可用。 如果你的项目使用JDK7，请使用Hutool 4.x版本（不再更新）\n\n\n# 1.4.3 编译安装\n\n访问Hutool的Gitee主页 clone整个项目源码（v5-master或v5-dev分支都可）然后进入Hutool项目目录执行：\n\n./hutool.sh install\n\n\n1\n\n\n然后就可以使用Maven引入啦。\n\n\n# 参考链接\n\nHuTool\n\n> 本文作者：许怀安\n> 创作时间：2022.01.26\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# 一、hutool的入门与安装\n\n\n# 1.1 简介\n\nhutool是一个小而全的java工具类库，通过静态方法封装，降低相关api的学习成本，提高工作效率，使java拥有函数式语言般的优雅，让java语言也可以甜甜的。\n\nhutool中的工具方法来自每个用户的精雕细琢，它涵盖了java开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；\n\nhutool是项目中util包友好的替代，它节省了开发人员对项目中公用类和公用工具方法的封装时间，使开发专注于业务，同时可以最大限度的避免封装不完善带来的bug。\n\n\n# 1.2 包含的组件\n\n一个java基础工具类，对文件、流、加密解密、转码、正则、线程、xml等jdk方法进行封装，组成各种util工具类，同时提供以下组件：\n\n模块                   介绍\nhutool-aop           jdk动态代理封装，提供非ioc下的切面支持\nhutool-bloomfilter   布隆过滤，提供一些hash算法的布隆过滤\nhutool-cache         简单缓存实现\nhutool-core          核心，包括bean操作、日期、各种util等\nhutool-cron          定时任务模块，提供类crontab表达式的定时任务\nhutool-crypto        加密解密模块，提供对称、非对称和摘要算法封装\nhutool-db            jdbc封装后的数据操作，基于activerecord思想\nhutool-dfa           基于dfa模型的多关键字查找\nhutool-extra         扩展模块，对第三方封装（模板引擎、邮件、servlet、二维码、emoji、ftp、分词等）\nhutool-http          基于httpurlconnection的http客户端封装\nhutool-log           自动识别日志实现的日志门面\nhutool-script        脚本执行封装，例如javascript\nhutool-setting       功能更强大的setting配置文件和properties封装\nhutool-system        系统参数调用封装（jvm信息等）\nhutool-json          json实现\nhutool-captcha       图片验证码实现\nhutool-poi           针对poi中excel和word的封装\nhutool-socket        基于java的nio和aio的socket封装\nhutool-jwt           json web token (jwt)封装实现\n\n可以根据需求对每个模块单独引入，也可以通过引入hutool-all方式引入所有模块。\n\n\n# 1.3 文档\n\n官方文档\n\n参考api\n\n\n# 1.4 安装hutool\n\n\n# 1.4.1 maven\n\n<dependency>\n    <groupid>cn.hutool</groupid>\n    <artifactid>hutool-all</artifactid>\n    <version>5.7.20</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 1.4.2 下载jar包\n\n通过maven中央库下载 hutool-all-x.x.x.jar 即可\n\n小tips\n\nhutool 5.x支持jdk8+，对android平台没有测试，不能保证所有工具类或工具方法可用。 如果你的项目使用jdk7，请使用hutool 4.x版本（不再更新）\n\n\n# 1.4.3 编译安装\n\n访问hutool的gitee主页 clone整个项目源码（v5-master或v5-dev分支都可）然后进入hutool项目目录执行：\n\n./hutool.sh install\n\n\n1\n\n\n然后就可以使用maven引入啦。\n\n\n# 参考链接\n\nhutool\n\n> 本文作者：许怀安\n> 创作时间：2022.01.26\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/02, 23:58:31",
      "lastUpdatedTimestamp": 1646236711000
    },
    {
      "title": "Hello gRPC",
      "frontmatter": {
        "title": "Hello gRPC",
        "date": "2022-01-10T21:59:38.000Z",
        "permalink": "/pages/793dcb",
        "article": "auto",
        "categories": [
          "gRPC笔记"
        ],
        "tags": [
          "gRPC",
          "Java"
        ]
      },
      "regularPath": "/Java/01.gRPC%E7%AC%94%E8%AE%B0/03.Hello_gRPC.html",
      "relativePath": "Java/01.gRPC笔记/03.Hello_gRPC.md",
      "key": "v-75ac0abd",
      "path": "/pages/793dcb/",
      "headers": [
        {
          "level": 2,
          "title": "3.1 服务端",
          "slug": "_3-1-服务端",
          "normalizedTitle": "3.1 服务端",
          "charIndex": 93
        },
        {
          "level": 3,
          "title": "开发环境配置",
          "slug": "开发环境配置",
          "normalizedTitle": "开发环境配置",
          "charIndex": 105
        },
        {
          "level": 3,
          "title": "服务定义",
          "slug": "服务定义",
          "normalizedTitle": "服务定义",
          "charIndex": 1247
        },
        {
          "level": 3,
          "title": "生成Java桩代码",
          "slug": "生成java桩代码",
          "normalizedTitle": "生成java桩代码",
          "charIndex": 2261
        },
        {
          "level": 3,
          "title": "服务端实现",
          "slug": "服务端实现",
          "normalizedTitle": "服务端实现",
          "charIndex": 3670
        },
        {
          "level": 2,
          "title": "3.2 服务端创建流程",
          "slug": "_3-2-服务端创建流程",
          "normalizedTitle": "3.2 服务端创建流程",
          "charIndex": 7857
        },
        {
          "level": 2,
          "title": "3.3 客户端",
          "slug": "_3-3-客户端",
          "normalizedTitle": "3.3 客户端",
          "charIndex": 8244
        },
        {
          "level": 3,
          "title": "请求流程",
          "slug": "请求流程",
          "normalizedTitle": "请求流程",
          "charIndex": 8256
        },
        {
          "level": 3,
          "title": "主要代码",
          "slug": "主要代码",
          "normalizedTitle": "主要代码",
          "charIndex": 8349
        },
        {
          "level": 2,
          "title": "3.4 客户端调用流程",
          "slug": "_3-4-客户端调用流程",
          "normalizedTitle": "3.4 客户端调用流程",
          "charIndex": 11738
        },
        {
          "level": 2,
          "title": "参考链接",
          "slug": "参考链接",
          "normalizedTitle": "参考链接",
          "charIndex": 12169
        }
      ],
      "headersStr": "3.1 服务端 开发环境配置 服务定义 生成Java桩代码 服务端实现 3.2 服务端创建流程 3.3 客户端 请求流程 主要代码 3.4 客户端调用流程 参考链接",
      "content": "# 三、Hello gRPC\n\n    以下参考 gRPC 官方文档的 demo 学习 gRPC 基本用法，实现服务端(Java)与客户端(Java)之间四种服务调用模式通信。\n\n\n# 3.1 服务端\n\n\n# 开发环境配置\n\n 1. 下载 protoc 编译器，配置环境变量，安装一个支持 proto 语法高亮的 IDEA 插件；\n\n 2. 新建 maven 项目，配置 pom.xml 添加对 Protobuf 的依赖：\n\n<dependencies>\n    <dependency>\n        <groupId>io.grpc</groupId>\n        <artifactId>grpc-netty</artifactId>\n        <version>${grpc.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>io.grpc</groupId>\n        <artifactId>grpc-protobuf</artifactId>\n        <version>${grpc.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>io.grpc</groupId>\n        <artifactId>grpc-stub</artifactId>\n        <version>${grpc.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>com.google.protobuf</groupId>\n        <artifactId>protobuf-java</artifactId>\n        <version>${protobuf.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>io.grpc</groupId>\n        <artifactId>grpc-all</artifactId>\n        <version>0.13.2</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n 3. 建立源码目录\n\n手动建立目录src/main/java保存服务实现源码，src/main/proto保存.proto 文件，注意这里要把 /proto 这个目录设置成源文件目录(Mark Directory as -> Sources Root)。\n\n\n# 服务定义\n\n在/proto 目录下，新建test.proto文件，定义四个 RPC 方法，分别对应四种服务类型，以及request和response的类型：\n\nsyntax = \"proto3\";    // 指定语法为 proto3 格式\noption java_package = \"me.misscoconut.rpc\";  // 生成 Java 类文件所在包名\noption java_outer_classname = \"GetProfile\";  // 生成的 Java 类名\noption java_multiple_files = true;  // 针对每个 message 和 ervice 都单独生成一个类；设置为 false,会以内部类的形式生成\n\nservice GetProfileService{\n  rpc getUsernameByID(ProfileRequest) returns (ProfileResponse);                  // Simple RPC\n  rpc getUsernamesByID(ProfileRequest) returns (stream ProfileResponse);          // Server Streaming\n  rpc getUsernameByIDs(stream ProfileRequest) returns (ProfileResponse);          // Client Streaming\n  rpc getUsernamesByIDs(stream ProfileRequest) returns (stream ProfileResponse);  // Bidirectional Streaming\n}\n\nmessage ProfileRequest{\n  string userID = 1;\n}\n\nmessage ProfileResponse{\n  string userName = 1;\n}\n\nmessage ProfileResponseList{\n  repeated ProfileResponse response = 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 生成Java桩代码\n\n在 pom.xml 配置 protobuf 插件:\n\n<build>\n       <extensions>\n           <extension>\n               <groupId>kr.motd.maven</groupId>\n               <artifactId>os-maven-plugin</artifactId>\n               <version>1.4.1.Final</version>\n           </extension>\n       </extensions>\n       <plugins>\n           <plugin>\n               <groupId>org.xolstice.maven.plugins</groupId>\n               <artifactId>protobuf-maven-plugin</artifactId>\n               <version>0.5.0</version>\n               <configuration>\n                   <protocArtifact>com.google.protobuf:protoc:3.3.0:exe:${os.detected.classifier}\n                   </protocArtifact>\n                   <pluginId>grpc-java</pluginId>\n                   <pluginArtifact>\n                       io.grpc:protoc-gen-grpc-java:1.4.0:exe:${os.detected.classifier}\n                   </pluginArtifact>\n               </configuration>\n               <executions>\n                   <execution>\n                       <goals>\n                           <goal>compile</goal>\n                           <goal>compile-custom</goal>\n                       </goals>\n                   </execution>\n               </executions>\n           </plugin>\n       </plugins>\n   </build>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n同步一下，maven compile 项目。/target/generated-sources 下生成的 java 桩代码，复制到 /src/main/java 下。\n\n\n# 服务端实现\n\n服务接口实现类继承自GetProfileServiceImplBase，重写基类里边的各服务方法。\n\n * 服务端创建:\n\nprivate void start() throws IOException {\n        // 指定 grpc 服务器端口，绑定服务接口实现，启动 grpc server\n        int port = 23333;\n        grpcServer = ServerBuilder.forPort(port)\n                .addService(new GetProfileServiceImpl())\n                .build()\n                .start();\n\n        System.out.println(\"GetProfileRpcServer.start,listing on port \" + port);\n\n        // 添加 hook，jvm 退出前关闭 tcp 连接\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                System.out.println(\"Shutting down GetProfileRpcServer since JVM is shutting down.\");\n                GetProfileRpcServer.this.stop();\n            }\n        });\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 服务接口实现\n\nprivate static class GetProfileServiceImpl extends GetProfileServiceGrpc.GetProfileServiceImplBase {\n       // Simple RPC\n       @Override\n       public void getUsernameByID(ProfileRequest request, StreamObserver<ProfileResponse> responseObserver) {\n           responseObserver.onNext(\n                   ProfileResponse.newBuilder().setUserName(\"simple rpc response.\").build());\n           responseObserver.onCompleted();\n       }\n\n       // Server Streaming\n       @Override\n       public void getUsernamesByID(ProfileRequest request, StreamObserver<ProfileResponse> responseObserver) {\n           List<ProfileResponse> responseList = new ArrayList<>();\n           responseList.add(ProfileResponse.newBuilder().setUserName(\"server streaming rpc response 1.\").build());\n           responseList.add(ProfileResponse.newBuilder().setUserName(\"server streaming rpc response 2.\").build());\n           responseList.add(ProfileResponse.newBuilder().setUserName(\"server streaming rpc response 3.\").build());\n           responseList.add(ProfileResponse.newBuilder().setUserName(\"server streaming rpc response 3.\").build());\n\n           for (ProfileResponse resp : responseList) {\n               responseObserver.onNext(resp);\n           }\n\n           responseObserver.onCompleted();\n       }\n\n       // Client Streaming\n       @Override\n       public StreamObserver<ProfileRequest> getUsernameByIDs(StreamObserver<ProfileResponse> responseObserver) {\n           List<String> reqFromClient = new ArrayList<>();\n           return new StreamObserver<ProfileRequest>() {\n               @Override\n               public void onNext(ProfileRequest profileRequest) {\n                   reqFromClient.add(profileRequest.getUserID());\n               }\n\n               @Override\n               public void onError(Throwable throwable) {\n                   System.out.println(\"GetProfileServiceImpl.onError\");\n               }\n\n               @Override\n               public void onCompleted() {\n                   for (String req : reqFromClient) {\n                       System.out.println(\"Client streaming request \" + req);\n                   }\n                   responseObserver.onNext(ProfileResponse.newBuilder().setUserName(\"Client streaming response.\").build());\n                   responseObserver.onCompleted();\n               }\n           };\n       }\n\n       // Bidirectional Streaming\n       @Override\n       public StreamObserver<ProfileRequest> getUsernamesByIDs(StreamObserver<ProfileResponse> responseObserver) {\n           return new StreamObserver<ProfileRequest>() {\n               @Override\n               public void onNext(ProfileRequest profileRequest) {\n                   responseObserver.onNext(ProfileResponse.newBuilder().setUserName(\"Bidirectional Streaming Server response.\").build());\n               }\n\n               @Override\n               public void onError(Throwable throwable) {\n                   System.out.println(\"GetProfileServiceImpl.onError\");\n               }\n\n               @Override\n               public void onCompleted() {\n                   responseObserver.onCompleted();\n               }\n           };\n       }\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# 3.2 服务端创建流程\n\n服务端创建过程主要涉及ServerBuilder、NettyServerProvider、GetProfileServiceImpl三个对象。\n\n大致流程：\n\n 1. 创建 Netty HTTP/2 服务端，监听指定的 Socket 地址；\n\n 2. 绑定 proto 文件中定义的服务接口实现类，将需要调用的服务端接口实现类注册到内部的注册中心；\n\n> 由于注册中心机制，gRPC 服务接口实现类的调用不需要通过动态代理和反射机制，而是通过 proto 工具生成代码，在服务端启动时，将服务接口实现类实例注册到 gRPC 内部的服务注册中心上。请求消息接入之后，可以根据服务名和方法名，直接调用启动时注册的服务实例，而不需要通过反射的方式进行调用，性能更高。\n\n 3. 创建 gRPC Server，用于 RPC 消息的统一调度和处理。\n\n\n# 3.3 客户端\n\n\n# 请求流程\n\n 1. 指定 ip:port 创建ManagedChannelImpl;\n 2. 创建客户端 Stub；\n 3. 使用客户端 Stub 发起 RPC 请求获得响应。\n\n\n# 主要代码\n\npublic static void main(String[] args) {\n    ManagedChannel channel = ManagedChannelBuilder.forTarget(\"localhost:23333\")\n            .usePlaintext(true)\n            .build();\n\n    GetProfileServiceGrpc.GetProfileServiceBlockingStub blockingStub = GetProfileServiceGrpc.newBlockingStub(channel);\n\n    // Unary\n    GetProfileServiceGrpc.GetProfileServiceStub stub = GetProfileServiceGrpc.newStub(channel);\n    ProfileResponse response = blockingStub\n            .getUsernameByID(ProfileRequest.newBuilder().setUserID(\"cocotest\").build());\n\n    System.out.println(response.getUserName());\n\n    // Client Streaming\n    Iterator<ProfileResponse> results =\n      blockingStub.getUsernamesByID(ProfileRequest.newBuilder().setUserID(\"cocotest\").build());\n    while (results.hasNext()) {\n        System.out.println(results.next().getUserName());\n    }\n\n    // Server Streaming\n    // 1. response\n    StreamObserver<ProfileResponse> responseStreamObserver = new StreamObserver<ProfileResponse>() {\n        @Override\n        public void onNext(ProfileResponse profileResponse) {\n            System.out.println(\"[Server Streaming] Client received :\" + profileResponse.getUserName());\n        }\n        @Override\n        public void onError(Throwable throwable) {\n            System.out.println(throwable.getMessage());\n        }\n        @Override\n        public void onCompleted() {\n            System.out.println(\"[Server Streaming] Client.onCompleted()\");\n        }\n    };\n    // 2. request\n    StreamObserver<ProfileRequest> usernameByIDs = stub.getUsernameByIDs(responseStreamObserver);\n    usernameByIDs.onNext(ProfileRequest.newBuilder().setUserID(\"ccc1111\").build());\n    usernameByIDs.onNext(ProfileRequest.newBuilder().setUserID(\"ccc2222\").build());\n    usernameByIDs.onNext(ProfileRequest.newBuilder().setUserID(\"ccc3333\").build());\n    usernameByIDs.onCompleted();\n    try {\n        Thread.sleep(2000);\n    } catch (\n            InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    // Bidirectional Streaming\n    StreamObserver<ProfileResponse> responseStreamObserver2 = new StreamObserver<ProfileResponse>() {\n        @Override\n        public void onNext(ProfileResponse value) {\n            System.out.println(\"[Bidirectional] Client received :\" + value.getUserName());\n        }\n\n        @Override\n        public void onError(Throwable t) {\n            System.out.println(t.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"[Bidirectional] Client.onCompleted()\");\n        }\n    };\n    StreamObserver<ProfileRequest> usernamesByIDs = stub.getUsernamesByIDs(responseStreamObserver2);\n    for (int i = 0; i < 10; i++) {\n        usernamesByIDs.onNext(ProfileRequest.newBuilder().setUserID(\"c:\" + i).build());\n        System.out.println(\"c:\" + i);\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    usernamesByIDs.onCompleted();\n    try {\n        Thread.sleep(30000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    channel.shutdown();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n# 3.4 客户端调用流程\n\n> 1.客户端 Stub(GetProfileServiceBlockingStub) 调用 getUsernameByID(request)，发起 RPC 调用；\n> \n> 2.通过 DnsNameResolver进行域名解析，获取服务端的地址信息（列表），随后使用默认的 LoadBalancer策略，选择一个具体的 gRPC 服务端实例；\n> \n> 3.如果与路由选中的服务端之间没有可用的连接，则创建 NettyClientTransport 和 NettyClientHandler，发起 HTTP/2 连接；对请求消息使用 Protobuf 做序列化，通过 HTTP/2 Stream 发送给 gRPC 服务端；\n> \n> 4.接收到服务端响应之后，使用 Protobuf 做反序列化；\n> \n> 5.回调 GrpcFuture 的 set(Response) 方法，唤醒阻塞的客户端调用线程，获取 RPC 响应。\n\n\n# 参考链接\n\ngRPC系列(三) 如何借助HTTP2实现传输\n深入理解Protobuf3协议原理\n\n> 本文作者：许怀安\n> 创作时间：2022.1.10\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# 三、hello grpc\n\n    以下参考 grpc 官方文档的 demo 学习 grpc 基本用法，实现服务端(java)与客户端(java)之间四种服务调用模式通信。\n\n\n# 3.1 服务端\n\n\n# 开发环境配置\n\n 1. 下载 protoc 编译器，配置环境变量，安装一个支持 proto 语法高亮的 idea 插件；\n\n 2. 新建 maven 项目，配置 pom.xml 添加对 protobuf 的依赖：\n\n<dependencies>\n    <dependency>\n        <groupid>io.grpc</groupid>\n        <artifactid>grpc-netty</artifactid>\n        <version>${grpc.version}</version>\n    </dependency>\n    <dependency>\n        <groupid>io.grpc</groupid>\n        <artifactid>grpc-protobuf</artifactid>\n        <version>${grpc.version}</version>\n    </dependency>\n    <dependency>\n        <groupid>io.grpc</groupid>\n        <artifactid>grpc-stub</artifactid>\n        <version>${grpc.version}</version>\n    </dependency>\n    <dependency>\n        <groupid>com.google.protobuf</groupid>\n        <artifactid>protobuf-java</artifactid>\n        <version>${protobuf.version}</version>\n    </dependency>\n    <dependency>\n        <groupid>io.grpc</groupid>\n        <artifactid>grpc-all</artifactid>\n        <version>0.13.2</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n 3. 建立源码目录\n\n手动建立目录src/main/java保存服务实现源码，src/main/proto保存.proto 文件，注意这里要把 /proto 这个目录设置成源文件目录(mark directory as -> sources root)。\n\n\n# 服务定义\n\n在/proto 目录下，新建test.proto文件，定义四个 rpc 方法，分别对应四种服务类型，以及request和response的类型：\n\nsyntax = \"proto3\";    // 指定语法为 proto3 格式\noption java_package = \"me.misscoconut.rpc\";  // 生成 java 类文件所在包名\noption java_outer_classname = \"getprofile\";  // 生成的 java 类名\noption java_multiple_files = true;  // 针对每个 message 和 ervice 都单独生成一个类；设置为 false,会以内部类的形式生成\n\nservice getprofileservice{\n  rpc getusernamebyid(profilerequest) returns (profileresponse);                  // simple rpc\n  rpc getusernamesbyid(profilerequest) returns (stream profileresponse);          // server streaming\n  rpc getusernamebyids(stream profilerequest) returns (profileresponse);          // client streaming\n  rpc getusernamesbyids(stream profilerequest) returns (stream profileresponse);  // bidirectional streaming\n}\n\nmessage profilerequest{\n  string userid = 1;\n}\n\nmessage profileresponse{\n  string username = 1;\n}\n\nmessage profileresponselist{\n  repeated profileresponse response = 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 生成java桩代码\n\n在 pom.xml 配置 protobuf 插件:\n\n<build>\n       <extensions>\n           <extension>\n               <groupid>kr.motd.maven</groupid>\n               <artifactid>os-maven-plugin</artifactid>\n               <version>1.4.1.final</version>\n           </extension>\n       </extensions>\n       <plugins>\n           <plugin>\n               <groupid>org.xolstice.maven.plugins</groupid>\n               <artifactid>protobuf-maven-plugin</artifactid>\n               <version>0.5.0</version>\n               <configuration>\n                   <protocartifact>com.google.protobuf:protoc:3.3.0:exe:${os.detected.classifier}\n                   </protocartifact>\n                   <pluginid>grpc-java</pluginid>\n                   <pluginartifact>\n                       io.grpc:protoc-gen-grpc-java:1.4.0:exe:${os.detected.classifier}\n                   </pluginartifact>\n               </configuration>\n               <executions>\n                   <execution>\n                       <goals>\n                           <goal>compile</goal>\n                           <goal>compile-custom</goal>\n                       </goals>\n                   </execution>\n               </executions>\n           </plugin>\n       </plugins>\n   </build>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n同步一下，maven compile 项目。/target/generated-sources 下生成的 java 桩代码，复制到 /src/main/java 下。\n\n\n# 服务端实现\n\n服务接口实现类继承自getprofileserviceimplbase，重写基类里边的各服务方法。\n\n * 服务端创建:\n\nprivate void start() throws ioexception {\n        // 指定 grpc 服务器端口，绑定服务接口实现，启动 grpc server\n        int port = 23333;\n        grpcserver = serverbuilder.forport(port)\n                .addservice(new getprofileserviceimpl())\n                .build()\n                .start();\n\n        system.out.println(\"getprofilerpcserver.start,listing on port \" + port);\n\n        // 添加 hook，jvm 退出前关闭 tcp 连接\n        runtime.getruntime().addshutdownhook(new thread() {\n            @override\n            public void run() {\n                system.out.println(\"shutting down getprofilerpcserver since jvm is shutting down.\");\n                getprofilerpcserver.this.stop();\n            }\n        });\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 服务接口实现\n\nprivate static class getprofileserviceimpl extends getprofileservicegrpc.getprofileserviceimplbase {\n       // simple rpc\n       @override\n       public void getusernamebyid(profilerequest request, streamobserver<profileresponse> responseobserver) {\n           responseobserver.onnext(\n                   profileresponse.newbuilder().setusername(\"simple rpc response.\").build());\n           responseobserver.oncompleted();\n       }\n\n       // server streaming\n       @override\n       public void getusernamesbyid(profilerequest request, streamobserver<profileresponse> responseobserver) {\n           list<profileresponse> responselist = new arraylist<>();\n           responselist.add(profileresponse.newbuilder().setusername(\"server streaming rpc response 1.\").build());\n           responselist.add(profileresponse.newbuilder().setusername(\"server streaming rpc response 2.\").build());\n           responselist.add(profileresponse.newbuilder().setusername(\"server streaming rpc response 3.\").build());\n           responselist.add(profileresponse.newbuilder().setusername(\"server streaming rpc response 3.\").build());\n\n           for (profileresponse resp : responselist) {\n               responseobserver.onnext(resp);\n           }\n\n           responseobserver.oncompleted();\n       }\n\n       // client streaming\n       @override\n       public streamobserver<profilerequest> getusernamebyids(streamobserver<profileresponse> responseobserver) {\n           list<string> reqfromclient = new arraylist<>();\n           return new streamobserver<profilerequest>() {\n               @override\n               public void onnext(profilerequest profilerequest) {\n                   reqfromclient.add(profilerequest.getuserid());\n               }\n\n               @override\n               public void onerror(throwable throwable) {\n                   system.out.println(\"getprofileserviceimpl.onerror\");\n               }\n\n               @override\n               public void oncompleted() {\n                   for (string req : reqfromclient) {\n                       system.out.println(\"client streaming request \" + req);\n                   }\n                   responseobserver.onnext(profileresponse.newbuilder().setusername(\"client streaming response.\").build());\n                   responseobserver.oncompleted();\n               }\n           };\n       }\n\n       // bidirectional streaming\n       @override\n       public streamobserver<profilerequest> getusernamesbyids(streamobserver<profileresponse> responseobserver) {\n           return new streamobserver<profilerequest>() {\n               @override\n               public void onnext(profilerequest profilerequest) {\n                   responseobserver.onnext(profileresponse.newbuilder().setusername(\"bidirectional streaming server response.\").build());\n               }\n\n               @override\n               public void onerror(throwable throwable) {\n                   system.out.println(\"getprofileserviceimpl.onerror\");\n               }\n\n               @override\n               public void oncompleted() {\n                   responseobserver.oncompleted();\n               }\n           };\n       }\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# 3.2 服务端创建流程\n\n服务端创建过程主要涉及serverbuilder、nettyserverprovider、getprofileserviceimpl三个对象。\n\n大致流程：\n\n 1. 创建 netty http/2 服务端，监听指定的 socket 地址；\n\n 2. 绑定 proto 文件中定义的服务接口实现类，将需要调用的服务端接口实现类注册到内部的注册中心；\n\n> 由于注册中心机制，grpc 服务接口实现类的调用不需要通过动态代理和反射机制，而是通过 proto 工具生成代码，在服务端启动时，将服务接口实现类实例注册到 grpc 内部的服务注册中心上。请求消息接入之后，可以根据服务名和方法名，直接调用启动时注册的服务实例，而不需要通过反射的方式进行调用，性能更高。\n\n 3. 创建 grpc server，用于 rpc 消息的统一调度和处理。\n\n\n# 3.3 客户端\n\n\n# 请求流程\n\n 1. 指定 ip:port 创建managedchannelimpl;\n 2. 创建客户端 stub；\n 3. 使用客户端 stub 发起 rpc 请求获得响应。\n\n\n# 主要代码\n\npublic static void main(string[] args) {\n    managedchannel channel = managedchannelbuilder.fortarget(\"localhost:23333\")\n            .useplaintext(true)\n            .build();\n\n    getprofileservicegrpc.getprofileserviceblockingstub blockingstub = getprofileservicegrpc.newblockingstub(channel);\n\n    // unary\n    getprofileservicegrpc.getprofileservicestub stub = getprofileservicegrpc.newstub(channel);\n    profileresponse response = blockingstub\n            .getusernamebyid(profilerequest.newbuilder().setuserid(\"cocotest\").build());\n\n    system.out.println(response.getusername());\n\n    // client streaming\n    iterator<profileresponse> results =\n      blockingstub.getusernamesbyid(profilerequest.newbuilder().setuserid(\"cocotest\").build());\n    while (results.hasnext()) {\n        system.out.println(results.next().getusername());\n    }\n\n    // server streaming\n    // 1. response\n    streamobserver<profileresponse> responsestreamobserver = new streamobserver<profileresponse>() {\n        @override\n        public void onnext(profileresponse profileresponse) {\n            system.out.println(\"[server streaming] client received :\" + profileresponse.getusername());\n        }\n        @override\n        public void onerror(throwable throwable) {\n            system.out.println(throwable.getmessage());\n        }\n        @override\n        public void oncompleted() {\n            system.out.println(\"[server streaming] client.oncompleted()\");\n        }\n    };\n    // 2. request\n    streamobserver<profilerequest> usernamebyids = stub.getusernamebyids(responsestreamobserver);\n    usernamebyids.onnext(profilerequest.newbuilder().setuserid(\"ccc1111\").build());\n    usernamebyids.onnext(profilerequest.newbuilder().setuserid(\"ccc2222\").build());\n    usernamebyids.onnext(profilerequest.newbuilder().setuserid(\"ccc3333\").build());\n    usernamebyids.oncompleted();\n    try {\n        thread.sleep(2000);\n    } catch (\n            interruptedexception e) {\n        e.printstacktrace();\n    }\n\n    // bidirectional streaming\n    streamobserver<profileresponse> responsestreamobserver2 = new streamobserver<profileresponse>() {\n        @override\n        public void onnext(profileresponse value) {\n            system.out.println(\"[bidirectional] client received :\" + value.getusername());\n        }\n\n        @override\n        public void onerror(throwable t) {\n            system.out.println(t.getmessage());\n        }\n\n        @override\n        public void oncompleted() {\n            system.out.println(\"[bidirectional] client.oncompleted()\");\n        }\n    };\n    streamobserver<profilerequest> usernamesbyids = stub.getusernamesbyids(responsestreamobserver2);\n    for (int i = 0; i < 10; i++) {\n        usernamesbyids.onnext(profilerequest.newbuilder().setuserid(\"c:\" + i).build());\n        system.out.println(\"c:\" + i);\n        try {\n            thread.sleep(500);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n    usernamesbyids.oncompleted();\n    try {\n        thread.sleep(30000);\n    } catch (interruptedexception e) {\n        e.printstacktrace();\n    }\n    channel.shutdown();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n# 3.4 客户端调用流程\n\n> 1.客户端 stub(getprofileserviceblockingstub) 调用 getusernamebyid(request)，发起 rpc 调用；\n> \n> 2.通过 dnsnameresolver进行域名解析，获取服务端的地址信息（列表），随后使用默认的 loadbalancer策略，选择一个具体的 grpc 服务端实例；\n> \n> 3.如果与路由选中的服务端之间没有可用的连接，则创建 nettyclienttransport 和 nettyclienthandler，发起 http/2 连接；对请求消息使用 protobuf 做序列化，通过 http/2 stream 发送给 grpc 服务端；\n> \n> 4.接收到服务端响应之后，使用 protobuf 做反序列化；\n> \n> 5.回调 grpcfuture 的 set(response) 方法，唤醒阻塞的客户端调用线程，获取 rpc 响应。\n\n\n# 参考链接\n\ngrpc系列(三) 如何借助http2实现传输\n深入理解protobuf3协议原理\n\n> 本文作者：许怀安\n> 创作时间：2022.1.10\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/10, 11:28:11",
      "lastUpdatedTimestamp": 1646882891000
    },
    {
      "title": "Hutoo组件",
      "frontmatter": {
        "title": "Hutoo组件",
        "date": "2022-01-26T21:23:53.000Z",
        "permalink": "/pages/f83d9d/",
        "categories": [
          "Java",
          "HuTool笔记"
        ],
        "tags": [
          "Java"
        ]
      },
      "regularPath": "/Java/02.HuTool%E7%AC%94%E8%AE%B0/02.Hutoo%E7%BB%84%E4%BB%B6.html",
      "relativePath": "Java/02.HuTool笔记/02.Hutoo组件.md",
      "key": "v-26361bfc",
      "path": "/pages/f83d9d/",
      "headers": [
        {
          "level": 2,
          "title": "2.1 I/O相关",
          "slug": "_2-1-i-o相关",
          "normalizedTitle": "2.1 i/o相关",
          "charIndex": 71
        },
        {
          "level": 3,
          "title": "2.1.1 文件",
          "slug": "_2-1-1-文件",
          "normalizedTitle": "2.1.1 文件",
          "charIndex": 85
        },
        {
          "level": 2,
          "title": "2.2 注解工具-AnnotationUtil",
          "slug": "_2-2-注解工具-annotationutil",
          "normalizedTitle": "2.2 注解工具-annotationutil",
          "charIndex": 2483
        },
        {
          "level": 3,
          "title": "介绍",
          "slug": "介绍",
          "normalizedTitle": "介绍",
          "charIndex": 2511
        },
        {
          "level": 3,
          "title": "使用",
          "slug": "使用-5",
          "normalizedTitle": "使用",
          "charIndex": 203
        }
      ],
      "headersStr": "2.1 I/O相关 2.1.1 文件 2.2 注解工具-AnnotationUtil 介绍 使用",
      "content": "# 二、HuTool部分组件说明\n\n说明\n\n这里只说明几个本人常用及用过的HuTool组件，未列出组件可移步HuTool官网文档查看\n\n\n# 2.1 I/O相关\n\n\n# 2.1.1 文件\n\n# 2.1.1.1 文件读取-FileReader\n\n# 背景\n\n在FileUtil中本来已经针对文件的读操作做了大量的静态封装，但是根据职责分离原则，我觉得有必要针对文件读取单独封装一个类，这样项目更加清晰。当然，使用FileUtil操作文件是最方便的。\n\n# 使用\n\n在JDK中，同样有一个FileReader类，但是并不如想象中的那样好用，于是Hutool便提供了更加便捷FileReader类。\n\n//默认UTF-8编码，可以在构造中传入第二个参数做为编码\nFileReader fileReader = new FileReader(\"test.properties\");\nString result = fileReader.readString();\n\n\n1\n2\n3\n\n\nFileReader提供了以下方法来快速读取文件内容：\n\n * readBytes\n * readString\n * readLines\n\n同时，此类还提供了以下方法用于转换为流或者BufferedReader：\n\n * getReader\n * getInputStream\n\n# 2.1.1.2 文件写入-FileWriter\n\n相应的，文件读取有了，自然有文件写入类，使用方式与FileReader也类似：\n\nFileWriter writer = new FileWriter(\"test.properties\");\nwriter.write(\"test\");\n\n\n1\n2\n\n\n写入文件分为追加模式和覆盖模式两类，追加模式可以用append方法，覆盖模式可以用write方法，同时也提供了一个write方法，第二个参数是可选覆盖模式。\n\n同样，此类提供了：\n\n * getOutputStream\n * getWriter\n * getPrintWriter\n\n这些方法用于转换为相应的类提供更加灵活的写入操作。\n\n# 2.1.1.3 文件追加-FileAppender\n\n# 背景\n\n顾名思义，FileAppender类表示文件追加器。此对象持有一个一个文件，在内存中积累一定量的数据后统一追加到文件，此类只有在写入文件时打开文件，并在写入结束后关闭之。因此此类不需要关闭。\n\n在调用append方法后会缓存于内存，只有超过容量后才会一次性写入文件，因此内存中随时有剩余未写入文件的内容，在最后必须调用flush方法将剩余内容刷入文件。\n\n也就是说，这是一个支持缓存的文件内容追加器。此类主要用于类似于日志写出这类需求所用。\n\n# 使用\n\nFileAppender appender = new FileAppender(file, 16, true);\nappender.append(\"123\");\nappender.append(\"abc\");\nappender.append(\"xyz\");\n\nappender.flush();\nappender.toString();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2.1.1.4 文件跟随-Tailer\n\n# 背景\n\n有时候我们要启动一个线程实时“监控”文件的变化，比如有新内容写出到文件时，我们可以及时打印出来，这个功能非常类似于Linux下的tail -f命令。\n\n# 使用\n\nTailer tailer = new Tailer(FileUtil.file(\"f:/test/test.log\"), Tailer.CONSOLE_HANDLER, 2);\ntailer.start();\n\n\n1\n2\n\n\n其中Tailer.CONSOLE_HANDLER表示文件新增内容默认输出到控制台。\n\n/**\n * 命令行打印的行处理器\n * \n * @author 许怀安\n * @since 4.5.2\n */\npublic static class ConsoleLineHandler implements LineHandler {\n    @Override\n    public void handle(String line) {\n        Console.log(line);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n我们也可以实现自己的LineHandler来处理每一行数据。\n\n注意\n\n此方法会阻塞当前线程\n\n# 2.1.1.5 文件名工具-FileNameUtil\n\n# 背景\n\n文件名操作工具类，主要针对文件名获取主文件名、扩展名等操作，同时针对Windows平台，清理无效字符。\n\n此工具类在5.4.1之前是FileUtil的一部分，后单独剥离为FileNameUtil工具。\n\n# 使用\n\n获取文件名\n\nFile file = FileUtil.file(\"/opt/test.txt\");\n\n// test.txt\nString name = FileNameUtil.getName(file);\n\n\n1\n2\n3\n4\n\n\n获取主文件名和扩展名\n\nFile file = FileUtil.file(\"/opt/test.txt\");\n\n// \"test\"\nString name = FileNameUtil.mainName(file);\n\n// \"txt\"\nString name = FileNameUtil.extName(file);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n此处获取的扩展名不带.。 FileNameUtil.mainName和FileNameUtil.getPrefix等价，同理FileNameUtil.extName和FileNameUtil.getSuffix等价，保留两个方法用于适应不同用户的习惯。\n\n\n# 2.2 注解工具-AnnotationUtil\n\n\n# 介绍\n\n封装了注解获取等方法的工具类。\n\n\n# 使用\n\n# 方法介绍\n\n1). 注解获取相关方法：\n\n * getAnnotations 获取指定类、方法、字段、构造等上的注解列表\n * getAnnotation 获取指定类型注解\n * getAnnotationValue 获取指定注解属性的值\n\n例：\n\n我们定义一个注解：\n\n// Retention注解决定MyAnnotation注解的生命周期\n@Retention(RetentionPolicy.RUNTIME)\n// Target注解决定MyAnnotation注解可以加在哪些成分上，如加在类身上，或者属性身上，或者方法身上等成分\n@Target({ ElementType.METHOD, ElementType.TYPE })\npublic @interface AnnotationForTest {\n    \n    /**\n     * 注解的默认属性值\n     * \n     * @return 属性值\n     */\n    String value();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n给需要的类加上注解：\n\n@AnnotationForTest(\"测试\")\npublic static class ClassWithAnnotation{\n  \n}\n\n\n1\n2\n3\n4\n\n\n获取注解中的值：\n\n// value为\"测试\"\nObject value = AnnotationUtil.getAnnotationValue(ClassWithAnnotation.class, AnnotationForTest.class);\n\n\n1\n2\n\n\n2). 注解属性获取相关方法： getRetentionPolicy 获取注解类的保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS\n\n * getTargetType 获取注解类可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等\n * isDocumented 是否会保存到 Javadoc 文档中\n * isInherited 是否可以被继承，默认为 false\n\n更多方法见API文档\n\n\n# 参考链接\n\nHuTool\n\n> 本文作者：许怀安\n> 创作时间：2022.01.26\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# 二、hutool部分组件说明\n\n说明\n\n这里只说明几个本人常用及用过的hutool组件，未列出组件可移步hutool官网文档查看\n\n\n# 2.1 i/o相关\n\n\n# 2.1.1 文件\n\n# 2.1.1.1 文件读取-filereader\n\n# 背景\n\n在fileutil中本来已经针对文件的读操作做了大量的静态封装，但是根据职责分离原则，我觉得有必要针对文件读取单独封装一个类，这样项目更加清晰。当然，使用fileutil操作文件是最方便的。\n\n# 使用\n\n在jdk中，同样有一个filereader类，但是并不如想象中的那样好用，于是hutool便提供了更加便捷filereader类。\n\n//默认utf-8编码，可以在构造中传入第二个参数做为编码\nfilereader filereader = new filereader(\"test.properties\");\nstring result = filereader.readstring();\n\n\n1\n2\n3\n\n\nfilereader提供了以下方法来快速读取文件内容：\n\n * readbytes\n * readstring\n * readlines\n\n同时，此类还提供了以下方法用于转换为流或者bufferedreader：\n\n * getreader\n * getinputstream\n\n# 2.1.1.2 文件写入-filewriter\n\n相应的，文件读取有了，自然有文件写入类，使用方式与filereader也类似：\n\nfilewriter writer = new filewriter(\"test.properties\");\nwriter.write(\"test\");\n\n\n1\n2\n\n\n写入文件分为追加模式和覆盖模式两类，追加模式可以用append方法，覆盖模式可以用write方法，同时也提供了一个write方法，第二个参数是可选覆盖模式。\n\n同样，此类提供了：\n\n * getoutputstream\n * getwriter\n * getprintwriter\n\n这些方法用于转换为相应的类提供更加灵活的写入操作。\n\n# 2.1.1.3 文件追加-fileappender\n\n# 背景\n\n顾名思义，fileappender类表示文件追加器。此对象持有一个一个文件，在内存中积累一定量的数据后统一追加到文件，此类只有在写入文件时打开文件，并在写入结束后关闭之。因此此类不需要关闭。\n\n在调用append方法后会缓存于内存，只有超过容量后才会一次性写入文件，因此内存中随时有剩余未写入文件的内容，在最后必须调用flush方法将剩余内容刷入文件。\n\n也就是说，这是一个支持缓存的文件内容追加器。此类主要用于类似于日志写出这类需求所用。\n\n# 使用\n\nfileappender appender = new fileappender(file, 16, true);\nappender.append(\"123\");\nappender.append(\"abc\");\nappender.append(\"xyz\");\n\nappender.flush();\nappender.tostring();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2.1.1.4 文件跟随-tailer\n\n# 背景\n\n有时候我们要启动一个线程实时“监控”文件的变化，比如有新内容写出到文件时，我们可以及时打印出来，这个功能非常类似于linux下的tail -f命令。\n\n# 使用\n\ntailer tailer = new tailer(fileutil.file(\"f:/test/test.log\"), tailer.console_handler, 2);\ntailer.start();\n\n\n1\n2\n\n\n其中tailer.console_handler表示文件新增内容默认输出到控制台。\n\n/**\n * 命令行打印的行处理器\n * \n * @author 许怀安\n * @since 4.5.2\n */\npublic static class consolelinehandler implements linehandler {\n    @override\n    public void handle(string line) {\n        console.log(line);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n我们也可以实现自己的linehandler来处理每一行数据。\n\n注意\n\n此方法会阻塞当前线程\n\n# 2.1.1.5 文件名工具-filenameutil\n\n# 背景\n\n文件名操作工具类，主要针对文件名获取主文件名、扩展名等操作，同时针对windows平台，清理无效字符。\n\n此工具类在5.4.1之前是fileutil的一部分，后单独剥离为filenameutil工具。\n\n# 使用\n\n获取文件名\n\nfile file = fileutil.file(\"/opt/test.txt\");\n\n// test.txt\nstring name = filenameutil.getname(file);\n\n\n1\n2\n3\n4\n\n\n获取主文件名和扩展名\n\nfile file = fileutil.file(\"/opt/test.txt\");\n\n// \"test\"\nstring name = filenameutil.mainname(file);\n\n// \"txt\"\nstring name = filenameutil.extname(file);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n此处获取的扩展名不带.。 filenameutil.mainname和filenameutil.getprefix等价，同理filenameutil.extname和filenameutil.getsuffix等价，保留两个方法用于适应不同用户的习惯。\n\n\n# 2.2 注解工具-annotationutil\n\n\n# 介绍\n\n封装了注解获取等方法的工具类。\n\n\n# 使用\n\n# 方法介绍\n\n1). 注解获取相关方法：\n\n * getannotations 获取指定类、方法、字段、构造等上的注解列表\n * getannotation 获取指定类型注解\n * getannotationvalue 获取指定注解属性的值\n\n例：\n\n我们定义一个注解：\n\n// retention注解决定myannotation注解的生命周期\n@retention(retentionpolicy.runtime)\n// target注解决定myannotation注解可以加在哪些成分上，如加在类身上，或者属性身上，或者方法身上等成分\n@target({ elementtype.method, elementtype.type })\npublic @interface annotationfortest {\n    \n    /**\n     * 注解的默认属性值\n     * \n     * @return 属性值\n     */\n    string value();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n给需要的类加上注解：\n\n@annotationfortest(\"测试\")\npublic static class classwithannotation{\n  \n}\n\n\n1\n2\n3\n4\n\n\n获取注解中的值：\n\n// value为\"测试\"\nobject value = annotationutil.getannotationvalue(classwithannotation.class, annotationfortest.class);\n\n\n1\n2\n\n\n2). 注解属性获取相关方法： getretentionpolicy 获取注解类的保留时间，可选值 source（源码时），class（编译时），runtime（运行时），默认为 class\n\n * gettargettype 获取注解类可以用来修饰哪些程序元素，如 type, method, constructor, field, parameter 等\n * isdocumented 是否会保存到 javadoc 文档中\n * isinherited 是否可以被继承，默认为 false\n\n更多方法见api文档\n\n\n# 参考链接\n\nhutool\n\n> 本文作者：许怀安\n> 创作时间：2022.01.26\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/02, 23:58:31",
      "lastUpdatedTimestamp": 1646236711000
    },
    {
      "title": "Home",
      "frontmatter": {
        "home": true,
        "heroImage": "/images/logo.jpg",
        "heroText": "XuHuaian,s Blog",
        "tagline": "记录自己的工作学习心得，争取当一条有梦想的咸鱼",
        "actionText": "开始探索之旅 →",
        "actionLink": "/categories/",
        "bannerBg": "none",
        "features": [
          {
            "title": "关于我",
            "details": "来自千禧年的IT民工，有点文艺，有点小年轻，希望能跟大家成为朋友"
          },
          {
            "title": "宅男",
            "details": "宅！ 宅！ 宅！"
          },
          {
            "title": "记录生活",
            "details": "记录生活中的点点滴滴，记录工作跟学习中的知识及BUG"
          }
        ],
        "postList": "simple"
      },
      "regularPath": "/",
      "relativePath": "index.md",
      "key": "v-7a5c0f68",
      "path": "/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/03/10, 11:28:11",
      "lastUpdatedTimestamp": 1646882891000
    },
    {
      "title": "使用systemctl命令管理部署Java jar包",
      "frontmatter": {
        "title": "使用systemctl命令管理部署Java jar包",
        "date": "2022-02-18T18:05:16.000Z",
        "permalink": "/pages/82aec0/",
        "categories": [
          "Java",
          "其他"
        ],
        "tags": [
          "scripts"
        ]
      },
      "regularPath": "/Java/03.%E5%85%B6%E4%BB%96/01.%E4%BD%BF%E7%94%A8systemctl%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%E9%83%A8%E7%BD%B2Java%20jar%E5%8C%85.html",
      "relativePath": "Java/03.其他/01.使用systemctl命令管理部署Java jar包.md",
      "key": "v-7e6d4a84",
      "path": "/pages/82aec0/",
      "headers": [
        {
          "level": 2,
          "title": "1.1 在目录/etc/systemd/system下建立hellword.service文件",
          "slug": "_1-1-在目录-etc-systemd-system下建立hellword-service文件",
          "normalizedTitle": "1.1 在目录/etc/systemd/system下建立hellword.service文件",
          "charIndex": 311
        },
        {
          "level": 2,
          "title": "1.2 在刚新建的.service中写入以下内容",
          "slug": "_1-2-在刚新建的-service中写入以下内容",
          "normalizedTitle": "1.2 在刚新建的.service中写入以下内容",
          "charIndex": 449
        },
        {
          "level": 2,
          "title": "3.1 执行start语句时，不成功，服务无法启动",
          "slug": "_3-1-执行start语句时-不成功-服务无法启动",
          "normalizedTitle": "3.1 执行start语句时，不成功，服务无法启动",
          "charIndex": 1631
        },
        {
          "level": 2,
          "title": "3.2 main process exited, code=exited, status=203/EXEC",
          "slug": "_3-2-main-process-exited-code-exited-status-203-exec",
          "normalizedTitle": "3.2 main process exited, code=exited, status=203/exec",
          "charIndex": 1740
        }
      ],
      "headersStr": "1.1 在目录/etc/systemd/system下建立hellword.service文件 1.2 在刚新建的.service中写入以下内容 3.1 执行start语句时，不成功，服务无法启动 3.2 main process exited, code=exited, status=203/EXEC",
      "content": "# 使用systemctl命令管理部署Java jar包\n\n\n# 说明\n\nJava项目编译完后通常都是 jar 包跟 war 包，war包都是在tomcat里面通过tomcat的管理方式来管理，而jar包一般都是通过 java -jar 或者 nohub java -jar 的方式来启动，而停止的话得先找出服务的进程ID，然后再kill掉，比较麻烦，使用systemctl来管理会更方便一点。\n\nsystemd是Linux系统最新的初始化系统，作用是方便管理系统服务，尽可能启动较少的进程，尽可能更多进程并发启动。 systemd对应的进程管理命令是systemctl\n\n\n# 一、在linux下部署服务步骤：\n\n\n# 1.1 在目录/etc/systemd/system下建立hellword.service文件\n\nmkdir /etc/systemd/system/helloword.service\n\n\n1\n\n\n提示\n\n后缀不变，名称随意，例如：helloword.service\n\n\n# 1.2 在刚新建的.service中写入以下内容\n\n[Unit]\nDescription=Spring Boot Application # 描述\nAfter=syslog.target network.target # 依赖\n\n[Service]\nExecStart=/usr/bin/java -jar /opt/javaapps/hellword.jar\n# 前面是java命令的绝对路径 后面是jar包的绝对路径\nExecStop=/bin/kill -15 $MAINPID\n\nUser=root \nGroup=root\n \n[Install]\nWantedBy=multi-user.target\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n.service文件定义了一个服务，分为 [Unit]，[Service]，[Install] 三个小节\n\n[Unit]\nDescription：描述\nAfter：在network.target,auditd.service启动后才启动\nConditionPathExists：执行条件\n\n\n[Service]\nEnvironmentFile：变量所在文件\nExecStart：执行启动脚本\nRestart：fail时重启\n\n\n[Install]\nAlias：服务别名\nWangtedBy：多用户模式下需要的\n\n\n\n# 二、使用命令 systemctl start xxx，如 systemctl start helloword\n\n\n# 2.1 常用命令\n\n二、常用命令\n\nsystemctl 提供了一组子命令来管理单个的 unit，其命令格式为：\n\nsystemctl [command] [unit]\n\ncommand 主要有：\nstart：立刻启动后面接的 unit。\nstop：立刻关闭后面接的 unit。\nrestart：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思。\nreload：不关闭 unit 的情况下，重新载入配置文件，让设置生效。\nenable：设置下次开机时，后面接的 unit 会被启动。\ndisable：设置下次开机时，后面接的 unit 不会被启动。\nstatus：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机时是否启动等信息。\nis-active：目前有没有正在运行中。\nis-enable：开机时有没有默认要启用这个 unit。\nkill ：不要被 kill 这个名字吓着了，它其实是向运行 unit 的进程发送信号。\nshow：列出 unit 的配置。\nmask：注销 unit，注销后你就无法启动这个 unit 了。\nunmask：取消对 unit 的注销。\n\n\n\n# 三、踩坑记录\n\n\n# 3.1 执行start语句时，不成功，服务无法启动\n\n通过执行 status 命令发现报错203，原因是因为文件权限不足需要提升文件权限\n\n解决办法\n\nchmod 755 helloword.jar\n\n\n1\n\n\n\n# 3.2 main process exited, code=exited, status=203/EXEC\n\n问题原因是jar包不是可执行的\n\n解决办法 修改pom文件，加入以下内容\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <configuration>\n                <finalName>${project.artifactId}</finalName>\n                <executable>true</executable>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 本文作者：许怀安\n> 创作时间：2022.02.18\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# 使用systemctl命令管理部署java jar包\n\n\n# 说明\n\njava项目编译完后通常都是 jar 包跟 war 包，war包都是在tomcat里面通过tomcat的管理方式来管理，而jar包一般都是通过 java -jar 或者 nohub java -jar 的方式来启动，而停止的话得先找出服务的进程id，然后再kill掉，比较麻烦，使用systemctl来管理会更方便一点。\n\nsystemd是linux系统最新的初始化系统，作用是方便管理系统服务，尽可能启动较少的进程，尽可能更多进程并发启动。 systemd对应的进程管理命令是systemctl\n\n\n# 一、在linux下部署服务步骤：\n\n\n# 1.1 在目录/etc/systemd/system下建立hellword.service文件\n\nmkdir /etc/systemd/system/helloword.service\n\n\n1\n\n\n提示\n\n后缀不变，名称随意，例如：helloword.service\n\n\n# 1.2 在刚新建的.service中写入以下内容\n\n[unit]\ndescription=spring boot application # 描述\nafter=syslog.target network.target # 依赖\n\n[service]\nexecstart=/usr/bin/java -jar /opt/javaapps/hellword.jar\n# 前面是java命令的绝对路径 后面是jar包的绝对路径\nexecstop=/bin/kill -15 $mainpid\n\nuser=root \ngroup=root\n \n[install]\nwantedby=multi-user.target\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n.service文件定义了一个服务，分为 [unit]，[service]，[install] 三个小节\n\n[unit]\ndescription：描述\nafter：在network.target,auditd.service启动后才启动\nconditionpathexists：执行条件\n\n\n[service]\nenvironmentfile：变量所在文件\nexecstart：执行启动脚本\nrestart：fail时重启\n\n\n[install]\nalias：服务别名\nwangtedby：多用户模式下需要的\n\n\n\n# 二、使用命令 systemctl start xxx，如 systemctl start helloword\n\n\n# 2.1 常用命令\n\n二、常用命令\n\nsystemctl 提供了一组子命令来管理单个的 unit，其命令格式为：\n\nsystemctl [command] [unit]\n\ncommand 主要有：\nstart：立刻启动后面接的 unit。\nstop：立刻关闭后面接的 unit。\nrestart：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思。\nreload：不关闭 unit 的情况下，重新载入配置文件，让设置生效。\nenable：设置下次开机时，后面接的 unit 会被启动。\ndisable：设置下次开机时，后面接的 unit 不会被启动。\nstatus：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机时是否启动等信息。\nis-active：目前有没有正在运行中。\nis-enable：开机时有没有默认要启用这个 unit。\nkill ：不要被 kill 这个名字吓着了，它其实是向运行 unit 的进程发送信号。\nshow：列出 unit 的配置。\nmask：注销 unit，注销后你就无法启动这个 unit 了。\nunmask：取消对 unit 的注销。\n\n\n\n# 三、踩坑记录\n\n\n# 3.1 执行start语句时，不成功，服务无法启动\n\n通过执行 status 命令发现报错203，原因是因为文件权限不足需要提升文件权限\n\n解决办法\n\nchmod 755 helloword.jar\n\n\n1\n\n\n\n# 3.2 main process exited, code=exited, status=203/exec\n\n问题原因是jar包不是可执行的\n\n解决办法 修改pom文件，加入以下内容\n\n<build>\n    <plugins>\n        <plugin>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-maven-plugin</artifactid>\n            <configuration>\n                <finalname>${project.artifactid}</finalname>\n                <executable>true</executable>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 本文作者：许怀安\n> 创作时间：2022.02.18\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/10, 11:28:11",
      "lastUpdatedTimestamp": 1646882891000
    },
    {
      "title": "关于我",
      "frontmatter": {
        "title": "关于我",
        "date": "2020-12-16T00:00:00.000Z",
        "permalink": "/pages/db78e2",
        "article": "auto",
        "categories": [
          "Other"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/Other/01.%E5%85%B3%E4%BA%8E%E6%88%91.html",
      "relativePath": "Other/01.关于我.md",
      "key": "v-4593f482",
      "path": "/pages/db78e2/",
      "headers": [
        {
          "level": 2,
          "title": "关于我",
          "slug": "关于我",
          "normalizedTitle": "关于我",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "博客说明",
          "slug": "博客说明",
          "normalizedTitle": "博客说明",
          "charIndex": 238
        },
        {
          "level": 2,
          "title": "联系",
          "slug": "联系",
          "normalizedTitle": "联系",
          "charIndex": 473
        }
      ],
      "headersStr": "关于我 博客说明 联系",
      "content": "# 关于我\n\n    男，千禧年IT民工，横走的巨蟹座，来自粗犷的大西北，三江源源头 - 青海。 高中毕业野路子一个，但对于IT技术有着浓厚的兴趣，功夫不负有心人，也算是为现在的事业打下了一点点基础，现任职一家甲方单位的开发运维岗位，偶尔接触一点安全工作，都说学一行爱一行，做一行爱一行，自从我做了从事了IT就爱上了这个职业，并通过自己的努力和学习对大多数IT技术都有了一定的了解。个人比较喜欢折腾，喜欢各种挑战，欢迎臭味相投的朋友随时滴我，一起互嗨互助，互相进步！\n\n\n# 博客说明\n\n    本博客最初是作为本人一个记录工作日常的小空间，记录一些平时工作跟学习上遇到的技术问题，虽然文章文笔不好，但都是我一个字一个字敲出来的，在写的时候我尽量清楚的表达出自己的想法，尽可能让看到我文章的朋友很容易就能理解其中的含义，但是我不敢保证自己一定能做得很好，如果有朋友觉得那里说的不清楚或者说错了，欢迎随时指教，我也好尽早修改，免得误导更多的人，毕竟既然做了博客，就要对它负责，将它做好。当然博客肯定还有很多做的不足的地方，希望能不吝赐教！\n\n\n# 联系\n\nEmail：keington@outlook.com\n\nBlog：https://dbsecurity.com.cn/\n\nQ Q： 1950974755\n\nWeChat：Xik-Zs",
      "normalizedContent": "# 关于我\n\n    男，千禧年it民工，横走的巨蟹座，来自粗犷的大西北，三江源源头 - 青海。 高中毕业野路子一个，但对于it技术有着浓厚的兴趣，功夫不负有心人，也算是为现在的事业打下了一点点基础，现任职一家甲方单位的开发运维岗位，偶尔接触一点安全工作，都说学一行爱一行，做一行爱一行，自从我做了从事了it就爱上了这个职业，并通过自己的努力和学习对大多数it技术都有了一定的了解。个人比较喜欢折腾，喜欢各种挑战，欢迎臭味相投的朋友随时滴我，一起互嗨互助，互相进步！\n\n\n# 博客说明\n\n    本博客最初是作为本人一个记录工作日常的小空间，记录一些平时工作跟学习上遇到的技术问题，虽然文章文笔不好，但都是我一个字一个字敲出来的，在写的时候我尽量清楚的表达出自己的想法，尽可能让看到我文章的朋友很容易就能理解其中的含义，但是我不敢保证自己一定能做得很好，如果有朋友觉得那里说的不清楚或者说错了，欢迎随时指教，我也好尽早修改，免得误导更多的人，毕竟既然做了博客，就要对它负责，将它做好。当然博客肯定还有很多做的不足的地方，希望能不吝赐教！\n\n\n# 联系\n\nemail：keington@outlook.com\n\nblog：https://dbsecurity.com.cn/\n\nq q： 1950974755\n\nwechat：xik-zs",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/02/28, 11:24:00",
      "lastUpdatedTimestamp": 1646018640000
    },
    {
      "title": "Windows下Java开发环境搭建",
      "frontmatter": {
        "title": "Windows下Java开发环境搭建",
        "date": "2021-12-15T10:11:38.000Z",
        "permalink": "/pages/a32ce8",
        "article": "auto",
        "categories": [
          "Java"
        ],
        "tags": [
          "Java"
        ]
      },
      "regularPath": "/%E5%85%B6%E4%BB%96/01.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/01.windows.html",
      "relativePath": "其他/01.环境搭建/01.windows.md",
      "key": "v-af985f62",
      "path": "/pages/a32ce8/",
      "headers": [
        {
          "level": 2,
          "title": "介绍",
          "slug": "介绍",
          "normalizedTitle": "介绍",
          "charIndex": 25
        },
        {
          "level": 2,
          "title": "Java开发与运行环境的搭建（Java SE）",
          "slug": "java开发与运行环境的搭建-java-se",
          "normalizedTitle": "java开发与运行环境的搭建（java se）",
          "charIndex": 1711
        },
        {
          "level": 2,
          "title": "IntelliJ IDEA工具的安装与配置",
          "slug": "intellij-idea工具的安装与配置",
          "normalizedTitle": "intellij idea工具的安装与配置",
          "charIndex": 2467
        }
      ],
      "headersStr": "介绍 Java开发与运行环境的搭建（Java SE） IntelliJ IDEA工具的安装与配置",
      "content": "# Windows下Java开发环境搭建\n\n\n# 介绍\n\n1. JDK+IntelliJ IDEA， 其中JDK的意思是Java开发工具包，IntelliJ IDEA是进行用于做Java程序开发的工具（IntelliJ IDEA 个人常用工具）\n\n其他开发工具：JCreator,JBuilder, Eclipse...\n\n2. Java的平台版本\n\n    Java分为J2SE、J2EE和J2ME三个不同的平台版本，即标准版（Java 2 Platform, Standard Edition）、企业版（Java 2 Platform, Enterprise Edition）和微型版（Java 2 Platform, Micro Edition）。从Java 1.5（或者Java 5.0）开始，它们被改称为Java SE、Java EE和Java ME。\n\n各平台版本之间的差别在于适用范围不同：\n\n标准版平台(Java SE) 允许开发和部署在桌面、服务器、嵌入式和实时环境中使用的Java应用程序。另外，Java SE包含了支持实现Java Web服务的类库，因此标准版是企业版的基础。\n\n企业版平台（Java EE） 帮助开发者开发和部署Java Web应用。企业版提供Web服务、组件模型、管理和通信API，可以用来实现企业级的面向服务的体系结构(Service-Oriented Architecture, SOA)和Web 2.0 应用程序。\n\n而微型版平台（Java ME） 主要用于移动设备和嵌入式设备，如手机、PDA、电视机顶盒等等。微型版包括灵活的用户界面、健壮的安全模型、许多内置的网络协议、以及对可动态下 载的在线和离线应用的支持。基于Java ME规范的应用程序与普通Java程序一样，只需编译一次，即可在许多设备上运行。\n\n3. Maven构建工具\n\n    Apache Maven是一个（特别是Java编程）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。\n\n    它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。当你使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。\n\n    Maven 有一个生命周期，当你运行 mvn install 的时候被调用。这条命令告诉 Maven 执行一系列的有序的步骤，直到到达你指定的生命周期。遍历生命周期旅途中的一个影响就是，Maven 运行了许多默认的插件目标，这些目标完成了像编译和创建一个 JAR 文件这样的工作。 此外，Maven能够很方便的帮你管理项目报告，生成站点，管理JAR文件，等等。\n\n4. Mysql数据库\n\n    MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。\n\n    MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n    MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。\n\n\n# Java开发与运行环境的搭建（Java SE）\n\n1. 下载JDK/JRE：\n\n    首先，访问Oracle公司的Java SE的下载主页，选择一个版本（我这里选择Java SE 8），选择Windows栏目，选择x64 Installer的Download下载链接\n\n提示\n\nOracle JDK下载之前得先注册Oracle账户才能下载\nOracle JDK 1.8_202以上为收费版本，从官网也能下载，但是为了避免侵权问题，建议下载1.8_202以下的\n\n    下载完成后双击打开 .exe 的安装包，安装到自己想要的指定位置，然后打开 此电脑-属性-高级系统设置-环境变量-系统变量-新建 ，添加两个变量名为 JAVA_HOME CLASSPATH ，JAVA_HOME变量值为刚才安装了JDK的安装路径，CLASSPATH变量值为.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n\n提示\n\n.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 前面有个 “.”\n\n    再双击打开 系统变量-Path-新建，添加变量值%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n\n提示\n\nWin7系统可将两个变量添加为一行\nWin10系统一个变量一个\n\n    至此，Windows下的JDK环境已经算是搭建完成，运行Windows PowerShell，输入\n\njava -version \njavac -version\n\n\n1\n2\n\n\n如果回显显示 java version \"1.8.0_xxx\" 跟 javac 1.8.0_xxx，则表明JDK环境已安装配置完成\n\n\n# IntelliJ IDEA工具的安装与配置\n\n    IntelliJ IDEA在业界被公认为最好的java开发工具，尤其在智能代码助手、代码自动提示、重构、JavaEE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java,Kotlin等少数语言。\n\n    访问JetBrains的IntelliJ IDEA下载页面下载安装包，下载下来后根据说明安装 .exe 的安装程序，待安装完成访问IntelliJ IDEA的账户注册页面创建账户，然后访问IntelliJ IDEA的授权购买页面后买授权，最后打开桌面上的IntelliJ IDEA，点击 帮助-注册，选择账户登录，待登陆完成就已完成IntelliJ IDEA的授权激活，至此也已完成IntelliJ IDEA的安装配置。\n\n> 本文作者：许怀安\n> 创作时间：2021.12.05\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# windows下java开发环境搭建\n\n\n# 介绍\n\n1. jdk+intellij idea， 其中jdk的意思是java开发工具包，intellij idea是进行用于做java程序开发的工具（intellij idea 个人常用工具）\n\n其他开发工具：jcreator,jbuilder, eclipse...\n\n2. java的平台版本\n\n    java分为j2se、j2ee和j2me三个不同的平台版本，即标准版（java 2 platform, standard edition）、企业版（java 2 platform, enterprise edition）和微型版（java 2 platform, micro edition）。从java 1.5（或者java 5.0）开始，它们被改称为java se、java ee和java me。\n\n各平台版本之间的差别在于适用范围不同：\n\n标准版平台(java se) 允许开发和部署在桌面、服务器、嵌入式和实时环境中使用的java应用程序。另外，java se包含了支持实现java web服务的类库，因此标准版是企业版的基础。\n\n企业版平台（java ee） 帮助开发者开发和部署java web应用。企业版提供web服务、组件模型、管理和通信api，可以用来实现企业级的面向服务的体系结构(service-oriented architecture, soa)和web 2.0 应用程序。\n\n而微型版平台（java me） 主要用于移动设备和嵌入式设备，如手机、pda、电视机顶盒等等。微型版包括灵活的用户界面、健壮的安全模型、许多内置的网络协议、以及对可动态下 载的在线和离线应用的支持。基于java me规范的应用程序与普通java程序一样，只需编译一次，即可在许多设备上运行。\n\n3. maven构建工具\n\n    apache maven是一个（特别是java编程）项目管理及自动构建工具，由apache软件基金会所提供。基于项目对象模型（缩写：pom）概念，maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。\n\n    它包含了一个项目对象模型 (project object model)，一组标准集合，一个项目生命周期(project lifecycle)，一个依赖管理系统(dependency management system)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。当你使用maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。\n\n    maven 有一个生命周期，当你运行 mvn install 的时候被调用。这条命令告诉 maven 执行一系列的有序的步骤，直到到达你指定的生命周期。遍历生命周期旅途中的一个影响就是，maven 运行了许多默认的插件目标，这些目标完成了像编译和创建一个 jar 文件这样的工作。 此外，maven能够很方便的帮你管理项目报告，生成站点，管理jar文件，等等。\n\n4. mysql数据库\n\n    mysql是一个关系型数据库管理系统，由瑞典mysql ab 公司开发，属于 oracle 旗下产品。mysql 是最流行的关系型数据库管理系统之一，在 web 应用方面，mysql是最好的 rdbms (relational database management system，关系数据库管理系统) 应用软件之一。\n\n    mysql是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n    mysql所使用的 sql 语言是用于访问数据库的最常用标准化语言。mysql 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 mysql 作为网站数据库。\n\n\n# java开发与运行环境的搭建（java se）\n\n1. 下载jdk/jre：\n\n    首先，访问oracle公司的java se的下载主页，选择一个版本（我这里选择java se 8），选择windows栏目，选择x64 installer的download下载链接\n\n提示\n\noracle jdk下载之前得先注册oracle账户才能下载\noracle jdk 1.8_202以上为收费版本，从官网也能下载，但是为了避免侵权问题，建议下载1.8_202以下的\n\n    下载完成后双击打开 .exe 的安装包，安装到自己想要的指定位置，然后打开 此电脑-属性-高级系统设置-环境变量-系统变量-新建 ，添加两个变量名为 java_home classpath ，java_home变量值为刚才安装了jdk的安装路径，classpath变量值为.;%java_home%\\lib\\dt.jar;%java_home%\\lib\\tools.jar;\n\n提示\n\n.;%java_home%\\lib\\dt.jar;%java_home%\\lib\\tools.jar 前面有个 “.”\n\n    再双击打开 系统变量-path-新建，添加变量值%java_home%\\bin;%java_home%\\jre\\bin;\n\n提示\n\nwin7系统可将两个变量添加为一行\nwin10系统一个变量一个\n\n    至此，windows下的jdk环境已经算是搭建完成，运行windows powershell，输入\n\njava -version \njavac -version\n\n\n1\n2\n\n\n如果回显显示 java version \"1.8.0_xxx\" 跟 javac 1.8.0_xxx，则表明jdk环境已安装配置完成\n\n\n# intellij idea工具的安装与配置\n\n    intellij idea在业界被公认为最好的java开发工具，尤其在智能代码助手、代码自动提示、重构、javaee支持、各类版本工具(git、svn等)、junit、cvs整合、代码分析、 创新的gui设计等方面的功能可以说是超常的。idea是jetbrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持html，css，php，mysql，python等。免费版只支持java,kotlin等少数语言。\n\n    访问jetbrains的intellij idea下载页面下载安装包，下载下来后根据说明安装 .exe 的安装程序，待安装完成访问intellij idea的账户注册页面创建账户，然后访问intellij idea的授权购买页面后买授权，最后打开桌面上的intellij idea，点击 帮助-注册，选择账户登录，待登陆完成就已完成intellij idea的授权激活，至此也已完成intellij idea的安装配置。\n\n> 本文作者：许怀安\n> 创作时间：2021.12.05\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/10, 11:28:11",
      "lastUpdatedTimestamp": 1646882891000
    },
    {
      "title": "Linux下Java运行环境搭建",
      "frontmatter": {
        "title": "Linux下Java运行环境搭建",
        "date": "2021-12-15T10:11:38.000Z",
        "permalink": "/pages/f22bdb",
        "article": "auto",
        "categories": [
          "Java"
        ],
        "tags": [
          "Java"
        ]
      },
      "regularPath": "/%E5%85%B6%E4%BB%96/01.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/02.linux.html",
      "relativePath": "其他/01.环境搭建/02.linux.md",
      "key": "v-19e6c50f",
      "path": "/pages/f22bdb/",
      "headers": [
        {
          "level": 2,
          "title": "1. 下载JDK/JRE：",
          "slug": "_1-下载jdk-jre",
          "normalizedTitle": "1. 下载jdk/jre：",
          "charIndex": 27
        }
      ],
      "headersStr": "1. 下载JDK/JRE：",
      "content": "# Java运行环境的搭建（Java SE）\n\n\n# 1. 下载JDK/JRE：\n\n    首先，访问Oracle公司的Java SE的下载主页，选择一个版本（我这里选择Java SE 8），选择Linux栏目，选择x86 Compressed Archive的Download下载链接\n\n提示\n\nOracle JDK下载之前得先注册Oracle账户才能下载\nOracle JDK 1.8_202以上为收费版本，从官网也能下载，但是为了避免侵权问题，建议下载1.8_202以下的\n下载JDK之前须先确认服务器的CPU硬件是x86还是Arm的，不同的CPU硬件是不同的安装包\n\n    下载完成后上传到测试/生产环境的服务器上，利用tar命令解压到/usr/local/目录下然后赋予755权限，然后使用vi/vim命令编辑/etc/profile将以下3-6行代码写入profile文件中，完成后按下键盘上的Esc键，然后输入 :wq 退出\n\nvim /etc/profile\n\n#JDK Path\nexport JAVA_HOME=/usr/local/jdk1.8.0_202\nexport CLASSPATH=.:${JAVA_HOME}/jre/lib/rt.jar:${JAVA_HOME}/lib/dt.jar:${JAVA_HOME}/lib/tools.jar\nexport PATH=$PATH:${JAVA_HOME}/bin\n\n\n1\n2\n3\n4\n5\n6\n\n\n最后执行以下命令使之生效\n\nsource /etc/profile\n\n\n1\n\n\n    至此，Linux下的Java运行环境已经算是搭建完成，在shell中输入\n\njava -version \n\njavac -version\n\n\n1\n2\n3\n\n\n如果回显显示 java version \"1.8.0_xxx\" 跟 javac 1.8.0_xxx，则表明JDK环境已安装配置完成\n\n> 本文作者：许怀安\n> 创作时间：2022.1.17\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# java运行环境的搭建（java se）\n\n\n# 1. 下载jdk/jre：\n\n    首先，访问oracle公司的java se的下载主页，选择一个版本（我这里选择java se 8），选择linux栏目，选择x86 compressed archive的download下载链接\n\n提示\n\noracle jdk下载之前得先注册oracle账户才能下载\noracle jdk 1.8_202以上为收费版本，从官网也能下载，但是为了避免侵权问题，建议下载1.8_202以下的\n下载jdk之前须先确认服务器的cpu硬件是x86还是arm的，不同的cpu硬件是不同的安装包\n\n    下载完成后上传到测试/生产环境的服务器上，利用tar命令解压到/usr/local/目录下然后赋予755权限，然后使用vi/vim命令编辑/etc/profile将以下3-6行代码写入profile文件中，完成后按下键盘上的esc键，然后输入 :wq 退出\n\nvim /etc/profile\n\n#jdk path\nexport java_home=/usr/local/jdk1.8.0_202\nexport classpath=.:${java_home}/jre/lib/rt.jar:${java_home}/lib/dt.jar:${java_home}/lib/tools.jar\nexport path=$path:${java_home}/bin\n\n\n1\n2\n3\n4\n5\n6\n\n\n最后执行以下命令使之生效\n\nsource /etc/profile\n\n\n1\n\n\n    至此，linux下的java运行环境已经算是搭建完成，在shell中输入\n\njava -version \n\njavac -version\n\n\n1\n2\n3\n\n\n如果回显显示 java version \"1.8.0_xxx\" 跟 javac 1.8.0_xxx，则表明jdk环境已安装配置完成\n\n> 本文作者：许怀安\n> 创作时间：2022.1.17\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/10, 11:28:11",
      "lastUpdatedTimestamp": 1646882891000
    },
    {
      "title": "VuePress-Vdoing搭建个人博客",
      "frontmatter": {
        "title": "VuePress-Vdoing搭建个人博客",
        "sidebar": "auto",
        "date": "2022-01-24T01:04:14.000Z",
        "permalink": "/pages/0737a0/",
        "categories": [
          "博客搭建"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/%E5%85%B6%E4%BB%96/02.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/01.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html",
      "relativePath": "其他/02.博客搭建/01.博客搭建.md",
      "key": "v-006b864a",
      "path": "/pages/0737a0/",
      "headers": [
        {
          "level": 2,
          "title": "为什么需要个人搭建博客",
          "slug": "为什么需要个人搭建博客",
          "normalizedTitle": "为什么需要个人搭建博客",
          "charIndex": 138
        },
        {
          "level": 2,
          "title": "什么是VuePress，为什么要使用VuePress",
          "slug": "什么是vuepress-为什么要使用vuepress",
          "normalizedTitle": "什么是vuepress，为什么要使用vuepress",
          "charIndex": null
        },
        {
          "level": 2,
          "title": "开始搭建",
          "slug": "开始搭建",
          "normalizedTitle": "开始搭建",
          "charIndex": 709
        },
        {
          "level": 2,
          "title": "一些小亮点",
          "slug": "一些小亮点",
          "normalizedTitle": "一些小亮点",
          "charIndex": 8652
        },
        {
          "level": 2,
          "title": "部署上线",
          "slug": "部署上线",
          "normalizedTitle": "部署上线",
          "charIndex": 10245
        }
      ],
      "headersStr": "为什么需要个人搭建博客 什么是VuePress，为什么要使用VuePress 开始搭建 一些小亮点 部署上线",
      "content": "# VuePress 搭建个人博客\n\n提示\n\n有阅读障碍的同学，可以跳过第一至四节，下载我写好的工具包:\n\ngit clone https://github.com/keington/vuepress-vdoing-blog.git\n\n\n1\n\n\n然后从第五节开始看。\n\n\n# 为什么需要个人搭建博客\n\n优秀的程序员都在写博客，写博客有很多好处：\n\n * 帮助自己梳理、总结、理解知识点（个人提升）\n * 帮助别人理解知识点（好人一生平安）\n * 简历更好看，更多面试机会（升职加薪）\n\n\n# 什么是VuePress，\n为什么要使用VuePress\n\n    VuePress 是尤雨溪（vue.js 框架作者）4月12日发布的一个全新的基于 vue 的静态网站生成器，实际上就是一个 vue 的 spa 应用，内置 webpack，可以用来写文档。详见 VuePress中文网\n\n    其实类似的建站工具有很多，比如 WordPress、Jekyll、Hexo 等，其中 WordPress 需要自己购买虚拟主机，不考虑；Jekyll 是 Github-Page 默认支持的，听说操作比较复杂，没有用过不做过多评价了；Hexo 之前一直在用，但一直觉得主题不好看，风格不够简洁优雅。自从遇见 VuePress，嗯，就是它了~ 真香~\n\nVuePress 有很多优点：\n\n * 界面简洁优雅（个人感觉比 HEXO 好看）\n * 容易上手（半小时能搭好整个项目）\n * 更好的兼容、扩展 Markdown 语法\n * 响应式布局，PC端、手机端\n * Google Analytics 集成\n * 支持 PWA\n\n\n# 开始搭建\n\n 1. 创建项目文件夹 可以右键手动新建，也可以使用 mkdir 命令新建：\n\n    mkdir vuepressBlogDemo\n\n\n1\n\n 2. 全局安装 VuePress\n\n    yarn install -g vuepress\n\n\n1\n\n 3. 进入 vuepressBlogDemo 文件夹，初始化项目 使用 yarn init 或 yarn init -y（默认yes）\n\n    yarn init -y\n\n\n1\n\n 4. 创建文件夹和文件 在 vuepressBlogDemo 文件夹中创建 docs 文件夹，在 docs 中创建 .vuepress 文件夹，在.vuepress中创建 public 文件夹和 config.js 文件，最终项目结构如下所示：\n\n    vuepressBlogDemo\n    ├─── docs\n    │   ├── README.md\n    │   └── .vuepress\n    │       ├── public\n    │       └── config.js\n    └── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 5. 在 config.js 文件中配置网站标题、描述、主题等信息\n\nmodule.exports = {\n   theme: 'vdoing', // 使用依赖包主题\n\n   title: \"XuHuaian,s Blog\",\n   description: '记录自己的工作学习心得，争取当一条有梦想的咸鱼',\n   // base: '/', // 默认'/'。如果你想将你的网站部署到如 https://foo.github.io/bar/，那么 base 应该被设置成 \"/bar/\",（否则页面将失去样式等文件）\n   markdown: {\n      lineNumbers: true // 代码块是否显示行号\n   },\n   serviceWorker: true, // 是否开启 PWA\n   head: [ // 注入到页面<head> 中的标签\n      ['link', { rel: 'icon', href: 'https://v3.cn.vuejs.org/logo.png' }], //favicon，资源放在public文件夹\n      ['meta', { name: 'theme-color', content: '#11a8cd' }], // 移动浏览器主题颜色\n   ],\n\n   // 主题配置\n   themeConfig: {\n      nav: [\n         { text: '首页', link: '/' },\n\n         {\n            text: '后端', items:[\n               // gRPC部分\n               {\n                  text: 'gRP笔记', items: [\n                     { text: 'RPC', link: '/pages/52d5c3/' },\n                     { text: 'gRPC', link: '/pages/a2f161/' },\n                     { text: 'Hello gRPC', link: '/pages/793dcb/' },\n                     { text: 'gRPC Bug', link: '/pages/2f674a/' },\n                  ],\n               },\n            ],\n         },\n\n         // Java部分\n         {\n            text: 'Java', items:[\n               // 环境搭建部分\n               {\n                  text: '环境搭建', items: [\n                     { text: 'Windows下Java开发环境搭建', link: '/pages/a32ce8/' },\n                     { text: 'Linux下Java运行环境搭建', link: '/pages/f22bdb/' },\n                  ],\n               },\n               // hutool笔记部分\n               {\n                  text: 'HuTool笔记', items: [\n                     { text: 'HuTool', link: '/pages/5fedc1/'},\n                     { text: 'HuTool组件', link: '/pages/f83d9d/'},\n                  ]\n               }\n            ],\n         },\n\n         // 运维部分\n         {\n            text: '运维', items:[\n               // 挖矿病毒部分\n               {\n                  text: 'Linux', items: [\n                     { text: 'Linux下挖矿病毒排杀过程', link: '/pages/af9ce4/' },\n                  ],\n               },\n            ],\n         },\n\n         {\n            text: '其他', items:[\n               // 挖矿病毒部分\n               {\n                  text: '02.博客搭建', items: [\n                     { text: 'Vuepress搭建博客', link: '/pages/0737a0/' },\n                  ],\n               },\n            ],\n         },\n\n         // 资源部分\n         // {\n         //   text: '资源', items: [\n         //     { text: 'Mysql', link: '/pages/023c74/'},\n         //     { text: '系统映像', link: '/pages/1361c7/'}\n         //   ],\n         // },\n\n         // { text: '案例', link: '/pages/5d571c/' },\n         { text: '关于我', link: '/pages/db78e2/' },\n         { text: 'Gitee', link: 'https://gitee.com/keington/vuepress-vdoing-blog' },\n         { text: 'Github', link: 'https://github.com/keington/vuepress-vdoing-blog.git'}\n      ],\n      sidebarDepth: 2, // 侧边栏显示深度，默认1，最大2（显示到h3标题）\n      logo: '/images/logo.jpg', // 导航栏logo\n      searchMaxSuggestions: 10, // 搜索结果显示最大数\n      lastUpdated: '上次更新', // 更新的时间，及前缀文字   string | boolean (取值为git提交时间)\n\n      // 以下配置是Vdoing主题改动的和新增的配置\n      sidebar: { mode: 'structuring', collapsable: false }, // 侧边栏  'structuring' | { mode: 'structuring', collapsable: Boolean} | 'auto' | 自定义    温馨提示：目录页数据依赖于结构化的侧边栏数据，如果你不设置为'structuring',将无法使用目录页\n\n      sidebarOpen: true, // 初始状态是否打开侧边栏，默认true\n      updateBar: { // 最近更新栏\n         showToArticle: false, // 显示到文章页底部，默认true\n         moreArticle: '/archives' // “更多文章”跳转的页面，默认'/archives'\n      },\n\n      // categoryText: '随笔', // 碎片化文章（_posts文件夹的文章）预设生成的分类值，默认'随笔'\n\n      // contentBgStyle: 1,\n\n      category: true, // 是否打开分类功能，默认true。 如打开，会做的事情有：1. 自动生成的frontmatter包含分类字段 2.页面中显示与分类相关的信息和模块 3.自动生成分类页面（在@pages文件夹）。如关闭，则反之。\n      tag: true, // 是否打开标签功能，默认true。 如打开，会做的事情有：1. 自动生成的frontmatter包含标签字段 2.页面中显示与标签相关的信息和模块 3.自动生成标签页面（在@pages文件夹）。如关闭，则反之。\n      archive: false, // 是否打开归档功能，默认true。 如打开，会做的事情有：1.自动生成归档页面（在@pages文件夹）。如关闭，则反之。\n\n      author: { // 文章默认的作者信息，可在md文件中单独配置此信息 String | {name: String, href: String}\n         name: '许怀安', // 必需\n         link :  'https://github.com/keington', // 作者链接（可选）\n      },\n\n      // 博主信息 (显示在首页侧边栏)\n      blogger: {\n         avatar: '/images/logo.jpg',\n         name: '许怀安',\n         slogan: '所思，所学，所想，所行',\n      },\n\n      social: { // 社交图标，显示于博主信息栏和页脚栏\n         iconfontCssFile: '//at.alicdn.com/t/font_1678482_u4nrnp8xp6g.css', // 可选，阿里图标库在线css文件地址，对于主题没有的图标可自由添加\n         icons: [\n            {\n               iconClass: 'icon-youjian',\n               title: 'Email',\n               link: 'mailto:keington@outlook.com'\n            },\n            {\n               iconClass: 'icon-QQ',\n               title: 'QQ',\n               link: 'tencent://message/?uin=qq1950974755&Site=Sambow&Menu=yes'\n            },\n            {\n               iconClass: 'icon-github',\n               title: 'Github',\n               link: 'https://github.com/keington/vuepress-vdoing-blog.git'\n            }\n         ]\n      },\n      footer: { // 页脚信息\n         createYear: 2020, // 博客创建年份\n         copyrightInfo: '许怀安 | MIT License', // 博客版权信息，支持a标签\n      },\n      htmlModules,\n   },\n\n   // 插件\n   plugins: [\n\n      ['fulltext-search'], // 全文搜索\n\n      // ['thirdparty-search', { // 可以添加第三方搜索链接的搜索框（原官方搜索框的参数仍可用）\n      //   thirdparty: [ // 可选，默认 []\n      //     {\n      //       title: '在GitHub中搜索',\n      //       frontUrl: 'https://github.com/search?q=', // 搜索链接的前面部分\n      //       behindUrl: '' // 搜索链接的后面部分，可选，默认 ''\n      //     },\n      //     {\n      //       title: '在npm中搜索',\n      //       frontUrl: 'https://www.npmjs.com/search?q=',\n      //     },\n      //     {\n      //       title: '在Bing中搜索',\n      //       frontUrl: 'https://cn.bing.com/search?q='\n      //     }\n      //   ]\n      // }],\n\n      ['one-click-copy', { // 代码块复制按钮\n         copySelector: ['div[class*=\"language-\"] pre', 'div[class*=\"aside-code\"] aside'], // String or Array\n         copyMessage: '复制成功', // default is 'Copy successfully and then paste it for use.'\n         duration: 1000, // prompt message display time.\n         showInMobile: false // whether to display on the mobile side, default: false.\n      }],\n      [\n         'vuepress-plugin-zooming', // 放大图片\n         {\n            selector: '.theme-vdoing-content img:not(.no-zoom)',\n            options: {\n               bgColor: 'rgba(0,0,0,0.6)'\n            },\n         },\n      ],\n      [\n         '@vuepress/last-updated', // \"上次更新\"时间格式\n         {\n            transformer: (timestamp, lang) => {\n               const dayjs = require('dayjs') // https://day.js.org/\n               return dayjs(timestamp).format('YYYY/MM/DD, HH:mm:ss')\n            },\n         }\n      ]\n   ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n\n 6. 在 package.json 文件里添加两个启动命令\n\n\"scripts\": {\n  \"dev\": \"vuepress dev docs\",\n  \"build\": \"vuepress build docs\"\n}\n\n\n1\n2\n3\n4\n\n 7. 一切就绪 🎉 跑起来看看吧\n\n    yarn dev\n\n\n1\n\n\n\n# 一些小亮点\n\n    完成了基础搭建后，就可以在docs目录下新建 .md 文件写文章了（.md 是 Markdown 语法文件，你需要知道 Markdown 的一些基本写法，很简单，这里给大家一份 Markdown 语法整理大集合）\n\n下面给大家安利一些实用的方法。\n\n 1. 代码块高亮 在 .md 文件中书写代码时，可在 ``` 后增加 js、html、json等格式类型，代码块即可按照指定类型高亮\n\n代码：\n\n``` js\nexport default {\n  data () {\n    return {\n      msg: 'Highlighted!'\n    }\n  }\n}\n```\n\n效果：\n\nexport default {\n  data () {\n    return {\n      msg: 'Highlighted!'\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 自定义容器\n\n代码：\n\n::: tip 提示\nthis is a tip\n:::\n\n::: warning 注意\nthis is a tip\n:::\n\n::: danger 警告\nthis is a tip\n:::\n\n\n效果：\n\n提示\n\nthis is a tip\n\n注意\n\nthis is a tip\n\n警告\n\nthis is a tip\n\n 3. 支持 Emoji 代码：\n    \n    🎉 💯 🎍 💝 🔥\n\n效果： 🎉 💯 🎍 💝 🔥\n\n👉 这里有一份 Emoji 大全\n\n 4. 支持 PWA VuePress 默认支持 PWA，配置方法如下：\n\nconfig.js 文件中增加\n\nhead: [ // 注入到当前页面的 HTML <head> 中的标签\n  ['link', { rel: 'manifest', href: '/photo.jpg' }],\n  ['link', { rel: 'apple-touch-icon', href: '/photo.jpg' }],\n],\nserviceWorker: true // 是否开启 PWA\n\n\n1\n2\n3\n4\n5\n\n\npublic 文件夹下新建 manifest.json 文件，添加\n\n{\n  \"name\": \"张三\",\n  \"short_name\": \"张三\",\n  \"start_url\": \"index.html\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#2196f3\",\n  \"description\": \"张三的个人主页\",\n  \"theme_color\": \"blue\",\n  \"icons\": [\n    {\n      \"src\": \"./photo.jpg\",\n      \"sizes\": \"144x144\",\n      \"type\": \"image/png\"\n    }\n  ],\n  \"related_applications\": [\n    {\n      \"platform\": \"web\"\n    },\n    {\n      \"platform\": \"play\",\n      \"url\": \"https://play.google.com/store/apps/details?id=cheeaun.hackerweb\"\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n 5. 最后在 iPhone 的 safrai 浏览器中打开本网站，点击 +添加到主屏幕 就能在桌面看到一个像原生 App 一样的图标（感觉自己写了一个 App 有木有 😄）\n\n\n# 部署上线\n\n    说了这么多都是在本地进行的，现在我们要把本地的内容推送到某个服务器上，这样只要有网络，就可以随时随地看自己的网站了。\n\n一般来说，有两种方案可供选择：\n\n 1. 自己买一个服务器，阿里云、腾讯云等，这种方式的好处是速度有保证、可以被搜索引擎收录，坏处是要花钱啊 💰 土豪同学可以考虑。\n\n 2. 使用 Gitee Pages 或者Github Pages。什么是 Gitee Pages / Github Pages呢？简单说就是 Gitee / Github提供的、用于搭建个人网站的静态站点托管服务。很多人用它搭建个人博客。这种方式的好处是免费、方便，坏处是速度可能会有些慢、不能被国内的搜索引擎收录。\n\n 3. 我的 Vuepress-Vdoing-Blog 已经开源放在了 Github 上，还有很多想要增加的功能，例如添加评论模块、自动生成侧边栏目录、增加网站分析工具等等，在这里欢迎大家 Star 或者 Fork 。",
      "normalizedContent": "# vuepress 搭建个人博客\n\n提示\n\n有阅读障碍的同学，可以跳过第一至四节，下载我写好的工具包:\n\ngit clone https://github.com/keington/vuepress-vdoing-blog.git\n\n\n1\n\n\n然后从第五节开始看。\n\n\n# 为什么需要个人搭建博客\n\n优秀的程序员都在写博客，写博客有很多好处：\n\n * 帮助自己梳理、总结、理解知识点（个人提升）\n * 帮助别人理解知识点（好人一生平安）\n * 简历更好看，更多面试机会（升职加薪）\n\n\n# 什么是vuepress，\n为什么要使用vuepress\n\n    vuepress 是尤雨溪（vue.js 框架作者）4月12日发布的一个全新的基于 vue 的静态网站生成器，实际上就是一个 vue 的 spa 应用，内置 webpack，可以用来写文档。详见 vuepress中文网\n\n    其实类似的建站工具有很多，比如 wordpress、jekyll、hexo 等，其中 wordpress 需要自己购买虚拟主机，不考虑；jekyll 是 github-page 默认支持的，听说操作比较复杂，没有用过不做过多评价了；hexo 之前一直在用，但一直觉得主题不好看，风格不够简洁优雅。自从遇见 vuepress，嗯，就是它了~ 真香~\n\nvuepress 有很多优点：\n\n * 界面简洁优雅（个人感觉比 hexo 好看）\n * 容易上手（半小时能搭好整个项目）\n * 更好的兼容、扩展 markdown 语法\n * 响应式布局，pc端、手机端\n * google analytics 集成\n * 支持 pwa\n\n\n# 开始搭建\n\n 1. 创建项目文件夹 可以右键手动新建，也可以使用 mkdir 命令新建：\n\n    mkdir vuepressblogdemo\n\n\n1\n\n 2. 全局安装 vuepress\n\n    yarn install -g vuepress\n\n\n1\n\n 3. 进入 vuepressblogdemo 文件夹，初始化项目 使用 yarn init 或 yarn init -y（默认yes）\n\n    yarn init -y\n\n\n1\n\n 4. 创建文件夹和文件 在 vuepressblogdemo 文件夹中创建 docs 文件夹，在 docs 中创建 .vuepress 文件夹，在.vuepress中创建 public 文件夹和 config.js 文件，最终项目结构如下所示：\n\n    vuepressblogdemo\n    ├─── docs\n    │   ├── readme.md\n    │   └── .vuepress\n    │       ├── public\n    │       └── config.js\n    └── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 5. 在 config.js 文件中配置网站标题、描述、主题等信息\n\nmodule.exports = {\n   theme: 'vdoing', // 使用依赖包主题\n\n   title: \"xuhuaian,s blog\",\n   description: '记录自己的工作学习心得，争取当一条有梦想的咸鱼',\n   // base: '/', // 默认'/'。如果你想将你的网站部署到如 https://foo.github.io/bar/，那么 base 应该被设置成 \"/bar/\",（否则页面将失去样式等文件）\n   markdown: {\n      linenumbers: true // 代码块是否显示行号\n   },\n   serviceworker: true, // 是否开启 pwa\n   head: [ // 注入到页面<head> 中的标签\n      ['link', { rel: 'icon', href: 'https://v3.cn.vuejs.org/logo.png' }], //favicon，资源放在public文件夹\n      ['meta', { name: 'theme-color', content: '#11a8cd' }], // 移动浏览器主题颜色\n   ],\n\n   // 主题配置\n   themeconfig: {\n      nav: [\n         { text: '首页', link: '/' },\n\n         {\n            text: '后端', items:[\n               // grpc部分\n               {\n                  text: 'grp笔记', items: [\n                     { text: 'rpc', link: '/pages/52d5c3/' },\n                     { text: 'grpc', link: '/pages/a2f161/' },\n                     { text: 'hello grpc', link: '/pages/793dcb/' },\n                     { text: 'grpc bug', link: '/pages/2f674a/' },\n                  ],\n               },\n            ],\n         },\n\n         // java部分\n         {\n            text: 'java', items:[\n               // 环境搭建部分\n               {\n                  text: '环境搭建', items: [\n                     { text: 'windows下java开发环境搭建', link: '/pages/a32ce8/' },\n                     { text: 'linux下java运行环境搭建', link: '/pages/f22bdb/' },\n                  ],\n               },\n               // hutool笔记部分\n               {\n                  text: 'hutool笔记', items: [\n                     { text: 'hutool', link: '/pages/5fedc1/'},\n                     { text: 'hutool组件', link: '/pages/f83d9d/'},\n                  ]\n               }\n            ],\n         },\n\n         // 运维部分\n         {\n            text: '运维', items:[\n               // 挖矿病毒部分\n               {\n                  text: 'linux', items: [\n                     { text: 'linux下挖矿病毒排杀过程', link: '/pages/af9ce4/' },\n                  ],\n               },\n            ],\n         },\n\n         {\n            text: '其他', items:[\n               // 挖矿病毒部分\n               {\n                  text: '02.博客搭建', items: [\n                     { text: 'vuepress搭建博客', link: '/pages/0737a0/' },\n                  ],\n               },\n            ],\n         },\n\n         // 资源部分\n         // {\n         //   text: '资源', items: [\n         //     { text: 'mysql', link: '/pages/023c74/'},\n         //     { text: '系统映像', link: '/pages/1361c7/'}\n         //   ],\n         // },\n\n         // { text: '案例', link: '/pages/5d571c/' },\n         { text: '关于我', link: '/pages/db78e2/' },\n         { text: 'gitee', link: 'https://gitee.com/keington/vuepress-vdoing-blog' },\n         { text: 'github', link: 'https://github.com/keington/vuepress-vdoing-blog.git'}\n      ],\n      sidebardepth: 2, // 侧边栏显示深度，默认1，最大2（显示到h3标题）\n      logo: '/images/logo.jpg', // 导航栏logo\n      searchmaxsuggestions: 10, // 搜索结果显示最大数\n      lastupdated: '上次更新', // 更新的时间，及前缀文字   string | boolean (取值为git提交时间)\n\n      // 以下配置是vdoing主题改动的和新增的配置\n      sidebar: { mode: 'structuring', collapsable: false }, // 侧边栏  'structuring' | { mode: 'structuring', collapsable: boolean} | 'auto' | 自定义    温馨提示：目录页数据依赖于结构化的侧边栏数据，如果你不设置为'structuring',将无法使用目录页\n\n      sidebaropen: true, // 初始状态是否打开侧边栏，默认true\n      updatebar: { // 最近更新栏\n         showtoarticle: false, // 显示到文章页底部，默认true\n         morearticle: '/archives' // “更多文章”跳转的页面，默认'/archives'\n      },\n\n      // categorytext: '随笔', // 碎片化文章（_posts文件夹的文章）预设生成的分类值，默认'随笔'\n\n      // contentbgstyle: 1,\n\n      category: true, // 是否打开分类功能，默认true。 如打开，会做的事情有：1. 自动生成的frontmatter包含分类字段 2.页面中显示与分类相关的信息和模块 3.自动生成分类页面（在@pages文件夹）。如关闭，则反之。\n      tag: true, // 是否打开标签功能，默认true。 如打开，会做的事情有：1. 自动生成的frontmatter包含标签字段 2.页面中显示与标签相关的信息和模块 3.自动生成标签页面（在@pages文件夹）。如关闭，则反之。\n      archive: false, // 是否打开归档功能，默认true。 如打开，会做的事情有：1.自动生成归档页面（在@pages文件夹）。如关闭，则反之。\n\n      author: { // 文章默认的作者信息，可在md文件中单独配置此信息 string | {name: string, href: string}\n         name: '许怀安', // 必需\n         link :  'https://github.com/keington', // 作者链接（可选）\n      },\n\n      // 博主信息 (显示在首页侧边栏)\n      blogger: {\n         avatar: '/images/logo.jpg',\n         name: '许怀安',\n         slogan: '所思，所学，所想，所行',\n      },\n\n      social: { // 社交图标，显示于博主信息栏和页脚栏\n         iconfontcssfile: '//at.alicdn.com/t/font_1678482_u4nrnp8xp6g.css', // 可选，阿里图标库在线css文件地址，对于主题没有的图标可自由添加\n         icons: [\n            {\n               iconclass: 'icon-youjian',\n               title: 'email',\n               link: 'mailto:keington@outlook.com'\n            },\n            {\n               iconclass: 'icon-qq',\n               title: 'qq',\n               link: 'tencent://message/?uin=qq1950974755&site=sambow&menu=yes'\n            },\n            {\n               iconclass: 'icon-github',\n               title: 'github',\n               link: 'https://github.com/keington/vuepress-vdoing-blog.git'\n            }\n         ]\n      },\n      footer: { // 页脚信息\n         createyear: 2020, // 博客创建年份\n         copyrightinfo: '许怀安 | mit license', // 博客版权信息，支持a标签\n      },\n      htmlmodules,\n   },\n\n   // 插件\n   plugins: [\n\n      ['fulltext-search'], // 全文搜索\n\n      // ['thirdparty-search', { // 可以添加第三方搜索链接的搜索框（原官方搜索框的参数仍可用）\n      //   thirdparty: [ // 可选，默认 []\n      //     {\n      //       title: '在github中搜索',\n      //       fronturl: 'https://github.com/search?q=', // 搜索链接的前面部分\n      //       behindurl: '' // 搜索链接的后面部分，可选，默认 ''\n      //     },\n      //     {\n      //       title: '在npm中搜索',\n      //       fronturl: 'https://www.npmjs.com/search?q=',\n      //     },\n      //     {\n      //       title: '在bing中搜索',\n      //       fronturl: 'https://cn.bing.com/search?q='\n      //     }\n      //   ]\n      // }],\n\n      ['one-click-copy', { // 代码块复制按钮\n         copyselector: ['div[class*=\"language-\"] pre', 'div[class*=\"aside-code\"] aside'], // string or array\n         copymessage: '复制成功', // default is 'copy successfully and then paste it for use.'\n         duration: 1000, // prompt message display time.\n         showinmobile: false // whether to display on the mobile side, default: false.\n      }],\n      [\n         'vuepress-plugin-zooming', // 放大图片\n         {\n            selector: '.theme-vdoing-content img:not(.no-zoom)',\n            options: {\n               bgcolor: 'rgba(0,0,0,0.6)'\n            },\n         },\n      ],\n      [\n         '@vuepress/last-updated', // \"上次更新\"时间格式\n         {\n            transformer: (timestamp, lang) => {\n               const dayjs = require('dayjs') // https://day.js.org/\n               return dayjs(timestamp).format('yyyy/mm/dd, hh:mm:ss')\n            },\n         }\n      ]\n   ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n\n 6. 在 package.json 文件里添加两个启动命令\n\n\"scripts\": {\n  \"dev\": \"vuepress dev docs\",\n  \"build\": \"vuepress build docs\"\n}\n\n\n1\n2\n3\n4\n\n 7. 一切就绪 🎉 跑起来看看吧\n\n    yarn dev\n\n\n1\n\n\n\n# 一些小亮点\n\n    完成了基础搭建后，就可以在docs目录下新建 .md 文件写文章了（.md 是 markdown 语法文件，你需要知道 markdown 的一些基本写法，很简单，这里给大家一份 markdown 语法整理大集合）\n\n下面给大家安利一些实用的方法。\n\n 1. 代码块高亮 在 .md 文件中书写代码时，可在 ``` 后增加 js、html、json等格式类型，代码块即可按照指定类型高亮\n\n代码：\n\n``` js\nexport default {\n  data () {\n    return {\n      msg: 'highlighted!'\n    }\n  }\n}\n```\n\n效果：\n\nexport default {\n  data () {\n    return {\n      msg: 'highlighted!'\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 自定义容器\n\n代码：\n\n::: tip 提示\nthis is a tip\n:::\n\n::: warning 注意\nthis is a tip\n:::\n\n::: danger 警告\nthis is a tip\n:::\n\n\n效果：\n\n提示\n\nthis is a tip\n\n注意\n\nthis is a tip\n\n警告\n\nthis is a tip\n\n 3. 支持 emoji 代码：\n    \n    🎉 💯 🎍 💝 🔥\n\n效果： 🎉 💯 🎍 💝 🔥\n\n👉 这里有一份 emoji 大全\n\n 4. 支持 pwa vuepress 默认支持 pwa，配置方法如下：\n\nconfig.js 文件中增加\n\nhead: [ // 注入到当前页面的 html <head> 中的标签\n  ['link', { rel: 'manifest', href: '/photo.jpg' }],\n  ['link', { rel: 'apple-touch-icon', href: '/photo.jpg' }],\n],\nserviceworker: true // 是否开启 pwa\n\n\n1\n2\n3\n4\n5\n\n\npublic 文件夹下新建 manifest.json 文件，添加\n\n{\n  \"name\": \"张三\",\n  \"short_name\": \"张三\",\n  \"start_url\": \"index.html\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#2196f3\",\n  \"description\": \"张三的个人主页\",\n  \"theme_color\": \"blue\",\n  \"icons\": [\n    {\n      \"src\": \"./photo.jpg\",\n      \"sizes\": \"144x144\",\n      \"type\": \"image/png\"\n    }\n  ],\n  \"related_applications\": [\n    {\n      \"platform\": \"web\"\n    },\n    {\n      \"platform\": \"play\",\n      \"url\": \"https://play.google.com/store/apps/details?id=cheeaun.hackerweb\"\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n 5. 最后在 iphone 的 safrai 浏览器中打开本网站，点击 +添加到主屏幕 就能在桌面看到一个像原生 app 一样的图标（感觉自己写了一个 app 有木有 😄）\n\n\n# 部署上线\n\n    说了这么多都是在本地进行的，现在我们要把本地的内容推送到某个服务器上，这样只要有网络，就可以随时随地看自己的网站了。\n\n一般来说，有两种方案可供选择：\n\n 1. 自己买一个服务器，阿里云、腾讯云等，这种方式的好处是速度有保证、可以被搜索引擎收录，坏处是要花钱啊 💰 土豪同学可以考虑。\n\n 2. 使用 gitee pages 或者github pages。什么是 gitee pages / github pages呢？简单说就是 gitee / github提供的、用于搭建个人网站的静态站点托管服务。很多人用它搭建个人博客。这种方式的好处是免费、方便，坏处是速度可能会有些慢、不能被国内的搜索引擎收录。\n\n 3. 我的 vuepress-vdoing-blog 已经开源放在了 github 上，还有很多想要增加的功能，例如添加评论模块、自动生成侧边栏目录、增加网站分析工具等等，在这里欢迎大家 star 或者 fork 。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/13, 01:11:03",
      "lastUpdatedTimestamp": 1647105063000
    },
    {
      "title": "Nginx报错403",
      "frontmatter": {
        "title": "Nginx报错403",
        "date": "2022-03-02T23:26:11.000Z",
        "permalink": "/pages/9c7c7b/",
        "categories": [
          "其他",
          "踩坑记录"
        ],
        "tags": [
          "Nginx"
        ]
      },
      "regularPath": "/%E5%85%B6%E4%BB%96/03.%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/01.Nginx%E6%8A%A5%E9%94%99403.html",
      "relativePath": "其他/03.踩坑记录/01.Nginx报错403.md",
      "key": "v-8e93adde",
      "path": "/pages/9c7c7b/",
      "headersStr": null,
      "content": "# Nginx报错403\n\n提示\n\n在前天给一小伙伴解决问题碰到个故障，觉得挺有意思，就记录下来\n\n环境\n\nOS：Centos\nWebServer：Nginx-v1.21.0\n语言：Vue\n\n\n\n# 说明\n\n在安装完nginx后测试是没什么问题，因为服务器上要跑的web程序有多个，所以配置文件是一个web站写一个，前端静态资源是用反向代理。\n\n\n# 解决过程\n\n刚开始访问报错403是以为是静态资源目录的问题，但是反复排查好几次没啥问题，也仔细排查了配置文件，也是没啥问题的，一直没有头绪该怎么解决，配置文件如下：\n\nnginx.conf\n\nuser  nginx;\nworker_processes  auto;\n\nerror_log  /var/log/nginx/error.log notice;\npid        /var/run/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    include /etc/nginx/conf.d/*.conf;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\ndefault.conf\n\n# HTTPS Config\nserver {\n    listen       443 ssl;\n    server_name  xxx.com;\n\n# SSL config\n    #ssl_certificate            /etc/nginx/cert/pem.pem;\n    #ssl_certificate_key        /etc/nginx/cert/key.key;\n    #ssl_session_timeout        5m;\n    #ssl_ciphers                ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    #ssl_protocols              TLSv1.1 TLSv1.2 TLSv1.3;\n    #ssl_prefer_server_ciphers  on;\n\n# Proxy Static resources\n    location / {\n        root                       /root/datas/dist;\n        index                      index.html index.htm; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n有关这个web站的所用东西属主及属组也都是nginx:nginx，后来静下心仔细一想 才发现root目录是root用户的私有目录，只能存在root权限，但是nginx的权限是nginx:nginx，所以在root目录下自然就读取不到\n\n于是将静态资源复制到非root目录下，重启nginx，一访问，可以访问到了😂。\n\n所以，要做一名合格的攻城狮还是要细心，这个问题本来就是一个很简单的属主属组问题，结果耗费了一个多小时\n\n> 本文作者：许怀安\n> 创作时间：2022.03.02\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# nginx报错403\n\n提示\n\n在前天给一小伙伴解决问题碰到个故障，觉得挺有意思，就记录下来\n\n环境\n\nos：centos\nwebserver：nginx-v1.21.0\n语言：vue\n\n\n\n# 说明\n\n在安装完nginx后测试是没什么问题，因为服务器上要跑的web程序有多个，所以配置文件是一个web站写一个，前端静态资源是用反向代理。\n\n\n# 解决过程\n\n刚开始访问报错403是以为是静态资源目录的问题，但是反复排查好几次没啥问题，也仔细排查了配置文件，也是没啥问题的，一直没有头绪该怎么解决，配置文件如下：\n\nnginx.conf\n\nuser  nginx;\nworker_processes  auto;\n\nerror_log  /var/log/nginx/error.log notice;\npid        /var/run/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    include /etc/nginx/conf.d/*.conf;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\ndefault.conf\n\n# https config\nserver {\n    listen       443 ssl;\n    server_name  xxx.com;\n\n# ssl config\n    #ssl_certificate            /etc/nginx/cert/pem.pem;\n    #ssl_certificate_key        /etc/nginx/cert/key.key;\n    #ssl_session_timeout        5m;\n    #ssl_ciphers                ecdhe-rsa-aes128-gcm-sha256:ecdhe:ecdh:aes:high:!null:!anull:!md5:!adh:!rc4;\n    #ssl_protocols              tlsv1.1 tlsv1.2 tlsv1.3;\n    #ssl_prefer_server_ciphers  on;\n\n# proxy static resources\n    location / {\n        root                       /root/datas/dist;\n        index                      index.html index.htm; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n有关这个web站的所用东西属主及属组也都是nginx:nginx，后来静下心仔细一想 才发现root目录是root用户的私有目录，只能存在root权限，但是nginx的权限是nginx:nginx，所以在root目录下自然就读取不到\n\n于是将静态资源复制到非root目录下，重启nginx，一访问，可以访问到了😂。\n\n所以，要做一名合格的攻城狮还是要细心，这个问题本来就是一个很简单的属主属组问题，结果耗费了一个多小时\n\n> 本文作者：许怀安\n> 创作时间：2022.03.02\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/13, 01:11:03",
      "lastUpdatedTimestamp": 1647105063000
    },
    {
      "title": "微信云托管部署Vuepress",
      "frontmatter": {
        "title": "微信云托管部署Vuepress",
        "date": "2022-03-13T00:24:27.000Z",
        "permalink": "/pages/c21fef/",
        "categories": [
          "其他",
          "博客搭建"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/%E5%85%B6%E4%BB%96/02.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/02.%E5%BE%AE%E4%BF%A1%E4%BA%91%E6%89%98%E7%AE%A1%E9%83%A8%E7%BD%B2Vuepress.html",
      "relativePath": "其他/02.博客搭建/02.微信云托管部署Vuepress.md",
      "key": "v-7e079f6a",
      "path": "/pages/c21fef/",
      "headers": [
        {
          "level": 2,
          "title": "微信云托管是什么",
          "slug": "微信云托管是什么",
          "normalizedTitle": "微信云托管是什么",
          "charIndex": 22
        },
        {
          "level": 2,
          "title": "Vuepress博客部署到微信云托管",
          "slug": "vuepress博客部署到微信云托管",
          "normalizedTitle": "vuepress博客部署到微信云托管",
          "charIndex": 750
        },
        {
          "level": 3,
          "title": "注意",
          "slug": "注意",
          "normalizedTitle": "注意",
          "charIndex": 945
        },
        {
          "level": 2,
          "title": "云托管绑定自定义域名",
          "slug": "云托管绑定自定义域名",
          "normalizedTitle": "云托管绑定自定义域名",
          "charIndex": 1927
        }
      ],
      "headersStr": "微信云托管是什么 Vuepress博客部署到微信云托管 注意 云托管绑定自定义域名",
      "content": "# 微信云托管部署Vuepress\n\n\n# 微信云托管是什么\n\n    微信云托管 是微信团队提供的以云原生为基础的，免运维、高可用服务上云解决方案，无需服务器，1分钟即可部署小程序/公众号服务端。\n\n微信云托管支持目前绝大多数语言/框架项目，开发者可以从服务器平滑迁移；并且微信云托管的自动运维和扩缩容特性，无需开发者关心服务的可用性，专注于业务，极大节省人力和服务资源成本。\n\n同时，微信云托管还集成持续交付部署，DevOps自动化，安全鉴权等众多能力，致力于帮助没有深层运维经验的业务开发者和研发团队，用最低的成本，打造出稳定性高，安全性强的后端服务。\n\n在微信云托管的助力下，项目服务可以达到和专业运维团队支撑一样的效果，同时又极大的节省人力和服务成本。\n\n微信云托管的高可用，免运维的基本特性，加上独家提供的微信生态核心能力，使得其在服务上云中有非常突出的优势。\n\n自动流水线：提供流水线能力，可以实现从代码仓库到服务发布的全自动流程，无需反复登录控制台操作;\n\n部署安全可控：提供灰度发布、定向开发测试、版本回滚等多样部署能力，业务更新迭代更稳更安全;\n\n机器人提醒：提供企业微信机器人提醒，第一时间告知发布情况;\n\n日志系统：对服务运行提供实时日志收集和查询能力，支持多种检索语法;\n\n资源监控：实时反映环境各个服务和各种资源的使用消耗情况，以及服务内版本运行的具体情况;\n\n资源告警：提供丰富的告警渠道，实时感知环境资源使用的各项指标运行情况，支持自定义规则;\n\n低改造成本：传统服务几乎无需改造成本，可快速迁移存量业务;\n\n支持微服务：支持东西向通信微服务和服务常驻，灵活设定，内网隔离;\n\n自定义域名：服务可以解析到自有域名，支持开启HTTPS，还有更多网关相关能力;\n\n\n\n# Vuepress博客部署到微信云托管\n\n    首先注册一个个人或企业的公众号（需实名），然后在云托管首页扫码登陆--选择刚才已创建的公众号即可，进去后系统会自动创建一个环境供使用；\n\n接着在服务管理--服务列表界面新建服务，选择 自定义部署，在选择代码这一步可以选择GitHub、Gitee或者Gitlab（选择对应的Git仓库需授权），然后选择需要部署的 分支然后点击发布即可\n\n\n# 注意\n\n提示\n\n在代码的根目录下需有Dockerfile构建文件，由于云托管官方没有发布vue项目的部署模板，在部署时使用如下文件即可\n\n注意\n\n在代码上传Git仓库前需先进行构建 npm run build 或 yarn build ，否则会部署失败，如不在本地进行构建须在Dcokerfile中加入Node的构建步骤\n\nDockerfile\n\nFROM nginx:latest\n\n# 设定用户组及用户为nginx\nENV RUN_USER nginx\nENV RUN_GROUP nginx\n\nENV DATA_DIR /data/www\n\n# 设定日志路径为/data/log/nginx\nENV LOG_DIR /data/log/nginx\n\n# 删除容器内默认的配置文件\nRUN rm -rf /etc/nginx/conf.d/default.conf\n\n# 指定工作目录\nWORKDIR /data/www\n\n# 复制配置文件到容器\nCOPY blog.conf /etc/nginx/conf.d\n\n# 复制构建后的文件到工作目录\nCOPY /docs/.vuepress/dist  /data/www\n\n# 指定运行端口\nEXPOSE 80\n\nENTRYPOINT nginx -g \"daemon off;\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n在根目录创建blog.conf，然后复制以下内容\n\n# HTTP Config\nserver {\n    listen       80;\n    server_name  dbsecurity.com.cn;\n\n# Proxy Static resources\n    location / {\n        root        /data/www;\n        index       index.html index.htm;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n将以上两个文件一起放到根目录下，然后推送到Git仓库，此时云托管会触发流水线任务，自动开始部署，等过一会使用云托管分配的公网域名访问就可看到博客内容。\n\n\n# 云托管绑定自定义域名\n\n在自定义域名界面选择绑定域名，填入你要绑定的域名及上传ssl证书\n\n提示\n\n在上传域名证书的签名证书时系统要求是 crt 格式，crt格式的签名证书是Apache的，在选择文件时可将格式改为所有文件，上传pem格式签名证书也可使用\n\n然后上传签名私钥，最后在域名所在商处做DNS解析，类型选择CNAME，记录填绑定完后控制台所显示的即可。\n\n> 本文作者：许怀安\n> 创作时间：2022.03.13\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# 微信云托管部署vuepress\n\n\n# 微信云托管是什么\n\n    微信云托管 是微信团队提供的以云原生为基础的，免运维、高可用服务上云解决方案，无需服务器，1分钟即可部署小程序/公众号服务端。\n\n微信云托管支持目前绝大多数语言/框架项目，开发者可以从服务器平滑迁移；并且微信云托管的自动运维和扩缩容特性，无需开发者关心服务的可用性，专注于业务，极大节省人力和服务资源成本。\n\n同时，微信云托管还集成持续交付部署，devops自动化，安全鉴权等众多能力，致力于帮助没有深层运维经验的业务开发者和研发团队，用最低的成本，打造出稳定性高，安全性强的后端服务。\n\n在微信云托管的助力下，项目服务可以达到和专业运维团队支撑一样的效果，同时又极大的节省人力和服务成本。\n\n微信云托管的高可用，免运维的基本特性，加上独家提供的微信生态核心能力，使得其在服务上云中有非常突出的优势。\n\n自动流水线：提供流水线能力，可以实现从代码仓库到服务发布的全自动流程，无需反复登录控制台操作;\n\n部署安全可控：提供灰度发布、定向开发测试、版本回滚等多样部署能力，业务更新迭代更稳更安全;\n\n机器人提醒：提供企业微信机器人提醒，第一时间告知发布情况;\n\n日志系统：对服务运行提供实时日志收集和查询能力，支持多种检索语法;\n\n资源监控：实时反映环境各个服务和各种资源的使用消耗情况，以及服务内版本运行的具体情况;\n\n资源告警：提供丰富的告警渠道，实时感知环境资源使用的各项指标运行情况，支持自定义规则;\n\n低改造成本：传统服务几乎无需改造成本，可快速迁移存量业务;\n\n支持微服务：支持东西向通信微服务和服务常驻，灵活设定，内网隔离;\n\n自定义域名：服务可以解析到自有域名，支持开启https，还有更多网关相关能力;\n\n\n\n# vuepress博客部署到微信云托管\n\n    首先注册一个个人或企业的公众号（需实名），然后在云托管首页扫码登陆--选择刚才已创建的公众号即可，进去后系统会自动创建一个环境供使用；\n\n接着在服务管理--服务列表界面新建服务，选择 自定义部署，在选择代码这一步可以选择github、gitee或者gitlab（选择对应的git仓库需授权），然后选择需要部署的 分支然后点击发布即可\n\n\n# 注意\n\n提示\n\n在代码的根目录下需有dockerfile构建文件，由于云托管官方没有发布vue项目的部署模板，在部署时使用如下文件即可\n\n注意\n\n在代码上传git仓库前需先进行构建 npm run build 或 yarn build ，否则会部署失败，如不在本地进行构建须在dcokerfile中加入node的构建步骤\n\ndockerfile\n\nfrom nginx:latest\n\n# 设定用户组及用户为nginx\nenv run_user nginx\nenv run_group nginx\n\nenv data_dir /data/www\n\n# 设定日志路径为/data/log/nginx\nenv log_dir /data/log/nginx\n\n# 删除容器内默认的配置文件\nrun rm -rf /etc/nginx/conf.d/default.conf\n\n# 指定工作目录\nworkdir /data/www\n\n# 复制配置文件到容器\ncopy blog.conf /etc/nginx/conf.d\n\n# 复制构建后的文件到工作目录\ncopy /docs/.vuepress/dist  /data/www\n\n# 指定运行端口\nexpose 80\n\nentrypoint nginx -g \"daemon off;\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n在根目录创建blog.conf，然后复制以下内容\n\n# http config\nserver {\n    listen       80;\n    server_name  dbsecurity.com.cn;\n\n# proxy static resources\n    location / {\n        root        /data/www;\n        index       index.html index.htm;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n将以上两个文件一起放到根目录下，然后推送到git仓库，此时云托管会触发流水线任务，自动开始部署，等过一会使用云托管分配的公网域名访问就可看到博客内容。\n\n\n# 云托管绑定自定义域名\n\n在自定义域名界面选择绑定域名，填入你要绑定的域名及上传ssl证书\n\n提示\n\n在上传域名证书的签名证书时系统要求是 crt 格式，crt格式的签名证书是apache的，在选择文件时可将格式改为所有文件，上传pem格式签名证书也可使用\n\n然后上传签名私钥，最后在域名所在商处做dns解析，类型选择cname，记录填绑定完后控制台所显示的即可。\n\n> 本文作者：许怀安\n> 创作时间：2022.03.13\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/13, 01:11:03",
      "lastUpdatedTimestamp": 1647105063000
    },
    {
      "title": "Linux下病毒排杀过程",
      "frontmatter": {
        "title": "Linux下病毒排杀过程",
        "date": "2021-11-05T20:23:51.000Z",
        "permalink": "/pages/af9ce4/",
        "categories": [
          "运维",
          "Linux"
        ],
        "tags": [
          "运维",
          "Linux",
          "安全"
        ]
      },
      "regularPath": "/%E8%BF%90%E7%BB%B4/01.Linux/01.Linux%E4%B8%8B%E7%97%85%E6%AF%92%E6%8E%92%E6%9D%80%E8%BF%87%E7%A8%8B.html",
      "relativePath": "运维/01.Linux/01.Linux下病毒排杀过程.md",
      "key": "v-3cbe3a5f",
      "path": "/pages/af9ce4/",
      "headers": [
        {
          "level": 2,
          "title": "1. 系统环境",
          "slug": "_1-系统环境",
          "normalizedTitle": "1. 系统环境",
          "charIndex": 21
        },
        {
          "level": 2,
          "title": "2. CPU架构",
          "slug": "_2-cpu架构",
          "normalizedTitle": "2. cpu架构",
          "charIndex": 79
        },
        {
          "level": 2,
          "title": "3. 事件来源",
          "slug": "_3-事件来源",
          "normalizedTitle": "3. 事件来源",
          "charIndex": 111
        },
        {
          "level": 2,
          "title": "4. 解决过程",
          "slug": "_4-解决过程",
          "normalizedTitle": "4. 解决过程",
          "charIndex": 299
        }
      ],
      "headersStr": "1. 系统环境 2. CPU架构 3. 事件来源 4. 解决过程",
      "content": "# Linux下挖矿病毒排杀过程\n\n\n# 1. 系统环境\n\nCentOS Linux release 7.6.1810 (AltArch)\n\n\n1\n\n\n\n# 2. CPU架构\n\nARM(Altarch)\n\n\n1\n\n\n\n# 3. 事件来源\n\n   3.1 最近发现生产服务器CPU占用过高但是查看进程却没有任何过高的进程， 最高也才是1点多，而且系统经常收到root用户发送的邮件 所以有理由是怀疑中了挖矿病毒，查看网络连接信息\n\nnetsts -napt\n\n\n1\n\n\n后发现一条疑似矿池的连接记录 然后去查找这个IP地址发现是M国的一个地址，去到某服安全中心查看这个IP果然是矿池地址无疑\n\n\n# 4. 解决过程\n\n   4.1 首先根据root用户发送给系统的邮件内容的路径去查看文件，\n\ncat /etc/ld.so.preload\n\n\n1\n\n\n   发现内容是/usr/local/lib/libprocesshider.so，是linux系统的一个链接库， 在这个文件里面写下的地址系统在运行程序时会自动去这些个目录里面找需要的动态库文件，先删除试一下\n\nrm /etc/ld.so.preload\n\n\n1\n\n\n  4.2 发现无法删除，查找资料后得知Linux系统还有一个叫文件锁定保护的命令，具体参数如下：\n\nchattr用法\n\nchattr [ -RV ] [ -v version ] [ mode ] files…\n\n最关键的是在[mode]部分，[mode]部分是由+-=和[ASacDdIijsTtu]这些字符组合的，这部分是用来控制文件的\n\n属性。\n\n * ：在原有参数设定基础上，追加参数。\n\n * ：在原有参数设定基础上，移除参数。\n\n= ：更新为指定参数设定。\n\nA：文件或目录的 atime (access time)不可被修改(modified), 可以有效预防例如手提电脑磁盘I/O错误的发生。\n\nS：硬盘I/O同步选项，功能类似sync。\n\na：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文 件安全，只有root才能设定这个属性。\n\nc：即compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作。\n\nd：即no dump，设定文件不能成为dump程序的备份目标。\n\ni：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助。\n\nj：即journal，设定此参数使得当通过 mount参数：data=ordered 或者 data=writeback 挂 载的文件系统， 文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data=journal，则该参数自动失效。\n\ns：保密性地删除文件或目录，即硬盘空间被全部收回。\n\nu：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion.\n\n各参数选项中常用到的是a和i。 a选项强制只可添加不可删除，多用于日志系统的安全设定。 而i是更为严格的安全设定，只有superuser (root) 或具有CAP_LINUX_IMMUTABLE处理能力（标识）的进程能够施加该选项。\n\n锁定文件：chattr +i 文件名\n\n解除锁定：chattr -i 文件名\n\n属性查看：lsattr 文件名\n\n如果在执行lsattr或是chattr命令时提示不存在，安装一下即可\n\nyum install -y e2fsprogs\n\n   4.3 先查看下/etc/ld.so.preload的锁定权限\n\nlsattr /etc/ld.so.preload\n\n\n1\n\n\n   4.4 使用chattr命令解除锁定然后删除\n\nchattr -i /etc/ld.so.preload\nrm -rf /etc/ld.so.preload\n\n\n1\n2\n\n\n   4.5 然后再对/usr/local/lib/libprocesshider.so进行操作，直接一步到位，解除锁定，然后删除\n\nchattr -i /usr/local/lib/libprocesshider.so\nrm -rf /usr/local/lib/libprocesshider.so\n\n\n1\n2\n\n\n   4.6 执行成功，继续下一步，查看定时任务，并清理，查询cron.d、cron.hourly、crontab目录或文件的异常\n\nlockr -i /etc/cron.d/phps\nrm -rf /etc/cron.d/phps\nlockr -i /sbin/httpss\nrm -rf /sbin/httpss\n\n\n1\n2\n3\n4\n\n\n   4.7 查看/etc/crontab文件内容,/etc/crontab是linux系统定时任务配置文件所在， 用vim编辑器删除最后3行，最后3行就是病毒链接所在，还是一样，不管有没有，先解除锁定，再修改\n\nchattr -i /etc/crontab\nvim /etc/crontab\n\n\n1\n2\n\n\n   4.8 查看定时任务并修改\n\ncrontab -l\ncrontab -e\n\n\n1\n2\n\n\n   4.9 回显提示crontab: error renaming    /var/spool/cron/#tmp.localhost.localdomain.XXXXPL0tU3 to /var/spool/cron/root    rename: 不允许的操作    crontab: edits left in /tmp/crontab.IFed5j    说明/var/spool/cron/root，/tmp/crontab.IFed5j这两个目录文件都有问题， 跟定时任务是相关联的，先清除这几个文件，防止上锁，先解锁，再删除\n\nchattr -ia /var/spool/cron/root\nrm -rf /var/spool/cron/root\nchattr -ia /tmp/crontab.IFed5j\nrm -rf /tmp/crontab.IFed5j\n\n\n1\n2\n3\n4\n\n\n   4.10 进入到/tmp目录下查看是否还有其他的缓存文件，如果有，一并删除（crontab -e所产生）\n\n   4.11 服务清理及自启动清理，查看/etc/rc.d/init.d/目录，/etc/rc.d/rc.local文件，/lib/systemd/system文件\n\ncd /etc/rc.d/init.d/ #无异常\n\n\n1\n\n\ncat /etc/rc.d/rc.local  #无异常\n\n\n1\n\n\ncd /lib/systemd/system  #发现异常服务文件\n\n\n1\n\n\nvim pwnriglhttps.service\n\nsystemctl stop pwnriglhttps.service\n\nsystemctl disable pwnriglhttps.service\n\n\n1\n2\n3\n4\n5\n\n\n   4.12 删除服务\n\nrm -rf pwnriglhttps.service\n\n\n1\n\n\n   4.13 查看系统hosts解析文件有无异常，如有异常用vim编辑器修改\n\ncat /etc/hosts\n\nvim /etc/hosts\n\n\n1\n2\n3\n\n\n   4.14 清理各目录下的病毒文件\n\nrm -rf /usr/bin/.sh\n\nrm -rf /bin/.sh\n\nlockr -i /bin/.funzip\n\nrm -rf /bin/.funzip\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n   4.15 查看/etc/profile文件\n\ncat /etc/profile\n\n\n1\n\n\n   4.16 回显显示最后4行文件有问题，用vim删除\n\nvim /etc/profile\n\n\n1\n\n\n   4.17 发现目录/etc/profile.d/下出现异常文件：php.sh、supervisor.sh\n\n   4.18 查看内容\n\ncd /etc/profile.d/\n\ncat php.sh\n\ncat supervisor.sh\n\n\n1\n2\n3\n4\n5\n\n\n   4.19 查看supervisor.sh显示/etc/.supervisor/supervisord.conf\n\n   4.20 删除删除php.sh，supervisor.sh，/etc/.supervisor/supervisord.conf\n\nlockr -i php.sh supervisor.sh\n\nrm -rf php.sh supervisor.sh\n\nlockr -i /etc/.supervisor/supervisord.conf\n\nrm -rf /etc/.supervisor/supervisord.conf\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n   4.21 最后删除/etc/.sh /usr/bin/.sh\n\nchattr -ia /etc/.sh /usr/bin/.sh\n\nrm -rf /etc/.sh /usr/bin/.sh\n\n\n1\n2\n3\n\n\n   4.22 最后清除邮件并重启\n\necho \"d *\" |mail -N\n\n\n1\n\n\nreboot\n\n\n1\n\n\n   4.23 开机后查看网络连接信息发现刚开始的那条IP已经没有了，说明残留的病毒文件已经清理完成\n\n   4.24 为了再次防止这个矿池来搞事情，最好在出口区域的安全设备的对该地址及域名相关进行封禁\n\n> 本文作者：许怀安\n> 创作时间：2021.11.05\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# linux下挖矿病毒排杀过程\n\n\n# 1. 系统环境\n\ncentos linux release 7.6.1810 (altarch)\n\n\n1\n\n\n\n# 2. cpu架构\n\narm(altarch)\n\n\n1\n\n\n\n# 3. 事件来源\n\n   3.1 最近发现生产服务器cpu占用过高但是查看进程却没有任何过高的进程， 最高也才是1点多，而且系统经常收到root用户发送的邮件 所以有理由是怀疑中了挖矿病毒，查看网络连接信息\n\nnetsts -napt\n\n\n1\n\n\n后发现一条疑似矿池的连接记录 然后去查找这个ip地址发现是m国的一个地址，去到某服安全中心查看这个ip果然是矿池地址无疑\n\n\n# 4. 解决过程\n\n   4.1 首先根据root用户发送给系统的邮件内容的路径去查看文件，\n\ncat /etc/ld.so.preload\n\n\n1\n\n\n   发现内容是/usr/local/lib/libprocesshider.so，是linux系统的一个链接库， 在这个文件里面写下的地址系统在运行程序时会自动去这些个目录里面找需要的动态库文件，先删除试一下\n\nrm /etc/ld.so.preload\n\n\n1\n\n\n  4.2 发现无法删除，查找资料后得知linux系统还有一个叫文件锁定保护的命令，具体参数如下：\n\nchattr用法\n\nchattr [ -rv ] [ -v version ] [ mode ] files…\n\n最关键的是在[mode]部分，[mode]部分是由+-=和[asacddiijsttu]这些字符组合的，这部分是用来控制文件的\n\n属性。\n\n * ：在原有参数设定基础上，追加参数。\n\n * ：在原有参数设定基础上，移除参数。\n\n= ：更新为指定参数设定。\n\na：文件或目录的 atime (access time)不可被修改(modified), 可以有效预防例如手提电脑磁盘i/o错误的发生。\n\ns：硬盘i/o同步选项，功能类似sync。\n\na：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文 件安全，只有root才能设定这个属性。\n\nc：即compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作。\n\nd：即no dump，设定文件不能成为dump程序的备份目标。\n\ni：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助。\n\nj：即journal，设定此参数使得当通过 mount参数：data=ordered 或者 data=writeback 挂 载的文件系统， 文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data=journal，则该参数自动失效。\n\ns：保密性地删除文件或目录，即硬盘空间被全部收回。\n\nu：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion.\n\n各参数选项中常用到的是a和i。 a选项强制只可添加不可删除，多用于日志系统的安全设定。 而i是更为严格的安全设定，只有superuser (root) 或具有cap_linux_immutable处理能力（标识）的进程能够施加该选项。\n\n锁定文件：chattr +i 文件名\n\n解除锁定：chattr -i 文件名\n\n属性查看：lsattr 文件名\n\n如果在执行lsattr或是chattr命令时提示不存在，安装一下即可\n\nyum install -y e2fsprogs\n\n   4.3 先查看下/etc/ld.so.preload的锁定权限\n\nlsattr /etc/ld.so.preload\n\n\n1\n\n\n   4.4 使用chattr命令解除锁定然后删除\n\nchattr -i /etc/ld.so.preload\nrm -rf /etc/ld.so.preload\n\n\n1\n2\n\n\n   4.5 然后再对/usr/local/lib/libprocesshider.so进行操作，直接一步到位，解除锁定，然后删除\n\nchattr -i /usr/local/lib/libprocesshider.so\nrm -rf /usr/local/lib/libprocesshider.so\n\n\n1\n2\n\n\n   4.6 执行成功，继续下一步，查看定时任务，并清理，查询cron.d、cron.hourly、crontab目录或文件的异常\n\nlockr -i /etc/cron.d/phps\nrm -rf /etc/cron.d/phps\nlockr -i /sbin/httpss\nrm -rf /sbin/httpss\n\n\n1\n2\n3\n4\n\n\n   4.7 查看/etc/crontab文件内容,/etc/crontab是linux系统定时任务配置文件所在， 用vim编辑器删除最后3行，最后3行就是病毒链接所在，还是一样，不管有没有，先解除锁定，再修改\n\nchattr -i /etc/crontab\nvim /etc/crontab\n\n\n1\n2\n\n\n   4.8 查看定时任务并修改\n\ncrontab -l\ncrontab -e\n\n\n1\n2\n\n\n   4.9 回显提示crontab: error renaming    /var/spool/cron/#tmp.localhost.localdomain.xxxxpl0tu3 to /var/spool/cron/root    rename: 不允许的操作    crontab: edits left in /tmp/crontab.ifed5j    说明/var/spool/cron/root，/tmp/crontab.ifed5j这两个目录文件都有问题， 跟定时任务是相关联的，先清除这几个文件，防止上锁，先解锁，再删除\n\nchattr -ia /var/spool/cron/root\nrm -rf /var/spool/cron/root\nchattr -ia /tmp/crontab.ifed5j\nrm -rf /tmp/crontab.ifed5j\n\n\n1\n2\n3\n4\n\n\n   4.10 进入到/tmp目录下查看是否还有其他的缓存文件，如果有，一并删除（crontab -e所产生）\n\n   4.11 服务清理及自启动清理，查看/etc/rc.d/init.d/目录，/etc/rc.d/rc.local文件，/lib/systemd/system文件\n\ncd /etc/rc.d/init.d/ #无异常\n\n\n1\n\n\ncat /etc/rc.d/rc.local  #无异常\n\n\n1\n\n\ncd /lib/systemd/system  #发现异常服务文件\n\n\n1\n\n\nvim pwnriglhttps.service\n\nsystemctl stop pwnriglhttps.service\n\nsystemctl disable pwnriglhttps.service\n\n\n1\n2\n3\n4\n5\n\n\n   4.12 删除服务\n\nrm -rf pwnriglhttps.service\n\n\n1\n\n\n   4.13 查看系统hosts解析文件有无异常，如有异常用vim编辑器修改\n\ncat /etc/hosts\n\nvim /etc/hosts\n\n\n1\n2\n3\n\n\n   4.14 清理各目录下的病毒文件\n\nrm -rf /usr/bin/.sh\n\nrm -rf /bin/.sh\n\nlockr -i /bin/.funzip\n\nrm -rf /bin/.funzip\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n   4.15 查看/etc/profile文件\n\ncat /etc/profile\n\n\n1\n\n\n   4.16 回显显示最后4行文件有问题，用vim删除\n\nvim /etc/profile\n\n\n1\n\n\n   4.17 发现目录/etc/profile.d/下出现异常文件：php.sh、supervisor.sh\n\n   4.18 查看内容\n\ncd /etc/profile.d/\n\ncat php.sh\n\ncat supervisor.sh\n\n\n1\n2\n3\n4\n5\n\n\n   4.19 查看supervisor.sh显示/etc/.supervisor/supervisord.conf\n\n   4.20 删除删除php.sh，supervisor.sh，/etc/.supervisor/supervisord.conf\n\nlockr -i php.sh supervisor.sh\n\nrm -rf php.sh supervisor.sh\n\nlockr -i /etc/.supervisor/supervisord.conf\n\nrm -rf /etc/.supervisor/supervisord.conf\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n   4.21 最后删除/etc/.sh /usr/bin/.sh\n\nchattr -ia /etc/.sh /usr/bin/.sh\n\nrm -rf /etc/.sh /usr/bin/.sh\n\n\n1\n2\n3\n\n\n   4.22 最后清除邮件并重启\n\necho \"d *\" |mail -n\n\n\n1\n\n\nreboot\n\n\n1\n\n\n   4.23 开机后查看网络连接信息发现刚开始的那条ip已经没有了，说明残留的病毒文件已经清理完成\n\n   4.24 为了再次防止这个矿池来搞事情，最好在出口区域的安全设备的对该地址及域名相关进行封禁\n\n> 本文作者：许怀安\n> 创作时间：2021.11.05\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/02, 23:58:31",
      "lastUpdatedTimestamp": 1646236711000
    },
    {
      "title": "Linux主机巡检脚本",
      "frontmatter": {
        "title": "Linux主机巡检脚本",
        "date": "2022-02-12T13:42:18.000Z",
        "permalink": "/pages/11d270/",
        "categories": [
          "运维",
          "Linux"
        ],
        "tags": [
          "运维",
          "Linux",
          "主机巡检"
        ]
      },
      "regularPath": "/%E8%BF%90%E7%BB%B4/01.Linux/02.Linux%E4%B8%BB%E6%9C%BA%E5%B7%A1%E6%A3%80%E8%84%9A%E6%9C%AC.html",
      "relativePath": "运维/01.Linux/02.Linux主机巡检脚本.md",
      "key": "v-390d1244",
      "path": "/pages/11d270/",
      "headersStr": null,
      "content": "#!/bin/bash\n# @Author: 许怀安\n# @Date:   2022-02-12\n# @E-mail: 1950974755@qq.com\n#主机信息每日巡检\n\nIPADDR=$(ifconfig |grep 'inet addr'|awk -F '[ :]' '{print $13}')\n#环境变量PATH没设好，在cron里执行时有很多命令会找不到\nexport PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin\nsource /etc/profile\n\n[ $(id -u) -gt 0 ] && echo \"请用root用户执行此脚本！\" && exit 1\ncentosVersion=$(awk '{print $(NF-1)}' /etc/redhat-release)\nVERSION=\"2021-12-17\"\n\n#日志相关\nPROGPATH=`echo $0 | sed -e 's,[\\\\/][^\\\\/][^\\\\/]*$,,'`\n[ -f $PROGPATH ] && PROGPATH=\".\"\nLOGPATH=\"$PROGPATH/log\"\n[ -e $LOGPATH ] || mkdir $LOGPATH\nRESULTFILE=\"$LOGPATH/Host_patrol_inspection-`date +%Y%m%d`.txt\"\n\n#定义报表的全局变量\nreport_DateTime=\"\" #日期 ok\nreport_Hostname=\"\" #主机名 ok\nreport_OSRelease=\"\" #发行版本 ok\nreport_Kernel=\"\" #内核 ok\nreport_Language=\"\" #语言/编码 ok\nreport_LastReboot=\"\" #最近启动时间 ok\nreport_Uptime=\"\" #运行时间（天） ok\nreport_CPUs=\"\" #CPU数量 ok\nreport_CPUType=\"\" #CPU类型 ok\nreport_Arch=\"\" #CPU架构 ok\nreport_MemTotal=\"\" #内存总容量(MB) ok\nreport_MemFree=\"\" #内存剩余(MB) ok\nreport_MemUsedPercent=\"\" #内存使用率% ok\nreport_DiskTotal=\"\" #硬盘总容量(GB) ok\nreport_DiskFree=\"\" #硬盘剩余(GB) ok\nreport_DiskUsedPercent=\"\" #硬盘使用率% ok\nreport_InodeTotal=\"\" #Inode总量 ok\nreport_InodeFree=\"\" #Inode剩余 ok\nreport_InodeUsedPercent=\"\" #Inode使用率 ok\nreport_IP=\"\" #IP地址 ok\nreport_MAC=\"\" #MAC地址 ok\nreport_Gateway=\"\" #默认网关 ok\nreport_DNS=\"\" #DNS ok\nreport_Listen=\"\" #监听 ok\nreport_Selinux=\"\" #Selinux ok\nreport_Firewall=\"\" #防火墙 ok\nreport_USERs=\"\" #用户 ok\nreport_USEREmptyPassword=\"\" #空密码用户 ok\nreport_USERTheSameUID=\"\" #相同ID的用户 ok\nreport_PasswordExpiry=\"\" #密码过期（天） ok\nreport_RootUser=\"\" #root用户 ok\nreport_Sudoers=\"\" #sudo授权 ok\nreport_SSHAuthorized=\"\" #SSH信任主机 ok\nreport_SSHDProtocolVersion=\"\" #SSH协议版本 ok\nreport_SSHDPermitRootLogin=\"\" #允许root远程登录 ok\nreport_DefunctProsess=\"\" #僵尸进程数量 ok\nreport_SelfInitiatedService=\"\" #自启动服务数量 ok\nreport_SelfInitiatedProgram=\"\" #自启动程序数量 ok\nreport_RuningService=\"\" #运行中服务数 ok\nreport_Crontab=\"\" #计划任务数 ok\nreport_Syslog=\"\" #日志服务 ok\nreport_SNMP=\"\" #SNMP OK\nreport_NTP=\"\" #NTP ok\nfunction version(){\necho \"系统巡检脚本：Version $VERSION\"\n}\n\nfunction getCpuStatus(){\necho \"\"\necho \"############################ CPU检查 #############################\"\nPhysical_CPUs=$(grep \"physical id\" /proc/cpuinfo| sort | uniq | wc -l)\nVirt_CPUs=$(grep \"processor\" /proc/cpuinfo | wc -l)\nCPU_Kernels=$(grep \"cores\" /proc/cpuinfo|uniq| awk -F ': ' '{print $2}')\nCPU_Type=$(grep \"model name\" /proc/cpuinfo | awk -F ': ' '{print $2}' | sort | uniq)\nCPU_Arch=$(uname -m)\necho \"物理CPU个数:$Physical_CPUs\"\necho \"逻辑CPU个数:$Virt_CPUs\"\necho \"每CPU核心数:$CPU_Kernels\"\necho \" CPU型号:$CPU_Type\"\necho \" CPU架构:$CPU_Arch\"\n#报表信息\nreport_CPUs=$Virt_CPUs #CPU数量\nreport_CPUType=$CPU_Type #CPU类型\nreport_Arch=$CPU_Arch #CPU架构\n}\n\nfunction getMemStatus(){\necho \"\"\necho \"############################ 内存检查 ############################\"\nif [[ $centosVersion < 7 ]];then\nfree -mo\nelse\nfree -h\nfi\n#报表信息\nMemTotal=$(grep MemTotal /proc/meminfo| awk '{print $2}') #KB\nMemFree=$(grep MemFree /proc/meminfo| awk '{print $2}') #KB\nlet MemUsed=MemTotal-MemFree\nMemPercent=$(awk \"BEGIN {if($MemTotal==0){printf 100}else{printf \\\"%.2f\\\",$MemUsed*100/$MemTotal}}\")\nreport_MemTotal=\"$((MemTotal/1024))\"\"MB\" #内存总容量(MB)\nreport_MemFree=\"$((MemFree/1024))\"\"MB\" #内存剩余(MB)\nreport_MemUsedPercent=\"$(awk \"BEGIN {if($MemTotal==0){printf 100}else{printf \\\"%.2f\\\",$MemUsed*100/$MemTotal}}\")\"\"%\" #内存使用率%\n}\nfunction getDiskStatus(){\necho \"\"\necho \"############################ 磁盘检查 ############################\"\ndf -hiP | sed 's/Mounted on/Mounted/'> /tmp/inode\ndf -hTP | sed 's/Mounted on/Mounted/'> /tmp/disk\njoin /tmp/disk /tmp/inode | awk '{print $1,$2,\"|\",$3,$4,$5,$6,\"|\",$8,$9,$10,$11,\"|\",$12}'| column -t\n#报表信息\ndiskdata=$(df -TP | sed '1d' | awk '$2!=\"tmpfs\"{print}') #KB\ndisktotal=$(echo \"$diskdata\" | awk '{total+=$3}END{print total}') #KB\ndiskused=$(echo \"$diskdata\" | awk '{total+=$4}END{print total}') #KB\ndiskfree=$((disktotal-diskused)) #KB\ndiskusedpercent=$(echo $disktotal $diskused | awk '{if($1==0){printf 100}else{printf \"%.2f\",$2*100/$1}}')\ninodedata=$(df -iTP | sed '1d' | awk '$2!=\"tmpfs\"{print}')\ninodetotal=$(echo \"$inodedata\" | awk '{total+=$3}END{print total}')\ninodeused=$(echo \"$inodedata\" | awk '{total+=$4}END{print total}')\ninodefree=$((inodetotal-inodeused))\ninodeusedpercent=$(echo $inodetotal $inodeused | awk '{if($1==0){printf 100}else{printf \"%.2f\",$2*100/$1}}')\nreport_DiskTotal=$((disktotal/1024/1024))\"GB\" #硬盘总容量(GB)\nreport_DiskFree=$((diskfree/1024/1024))\"GB\" #硬盘剩余(GB)\nreport_DiskUsedPercent=\"$diskusedpercent\"\"%\" #硬盘使用率%\nreport_InodeTotal=$((inodetotal/1000))\"K\" #Inode总量\nreport_InodeFree=$((inodefree/1000))\"K\" #Inode剩余\nreport_InodeUsedPercent=\"$inodeusedpercent\"\"%\" #Inode使用率%\n\n}\n\nfunction getSystemStatus(){\necho \"\"\necho \"############################ 系统检查 ############################\"\nif [ -e /etc/sysconfig/i18n ];then\ndefault_LANG=\"$(grep \"LANG=\" /etc/sysconfig/i18n | grep -v \"^#\" | awk -F '\"' '{print $2}')\"\nelse\ndefault_LANG=$LANG\nfi\nexport LANG=\"en_US.UTF-8\"\nRelease=$(cat /etc/redhat-release 2>/dev/null)\nKernel=$(uname -r)\nOS=$(uname -o)\nHostname=$(uname -n)\nSELinux=$(/usr/sbin/sestatus | grep \"SELinux status: \" | awk '{print $3}')\nLastReboot=$(who -b | awk '{print $3,$4}')\nuptime=$(uptime | sed 's/.*up \\([^,]*\\), .*/\\1/')\necho \" 系统：$OS\"\necho \" 发行版本：$Release\"\necho \" 内核：$Kernel\"\necho \" 主机名：$Hostname\"\necho \" SELinux：$SELinux\"\necho \"语言/编码：$default_LANG\"\necho \" 当前时间：$(date +'%F %T')\"\necho \" 最后启动：$LastReboot\"\necho \" 运行时间：$uptime\"\n#报表信息\nreport_DateTime=$(date +\"%F %T\") #日期\nreport_Hostname=\"$Hostname\" #主机名\nreport_OSRelease=\"$Release\" #发行版本\nreport_Kernel=\"$Kernel\" #内核\nreport_Language=\"$default_LANG\" #语言/编码\nreport_LastReboot=\"$LastReboot\" #最近启动时间\nreport_Uptime=\"$uptime\" #运行时间（天）\nreport_Selinux=\"$SELinux\"\nexport LANG=\"$default_LANG\"\n\n}\n\nfunction getServiceStatus(){\necho \"\"\necho \"############################ 服务检查 ############################\"\necho \"\"\nif [[ $centosVersion > 7 ]];then\nconf=$(systemctl list-unit-files --type=service --state=enabled --no-pager | grep \"enabled\")\nprocess=$(systemctl list-units --type=service --state=running --no-pager | grep \".service\")\n#报表信息\nreport_SelfInitiatedService=\"$(echo \"$conf\" | wc -l)\" #自启动服务数量\nreport_RuningService=\"$(echo \"$process\" | wc -l)\" #运行中服务数量\nelse\nconf=$(/sbin/chkconfig | grep -E \":on|:启用\")\nprocess=$(/sbin/service --status-all 2>/dev/null | grep -E \"is running|正在运行\")\n#报表信息\nreport_SelfInitiatedService=\"$(echo \"$conf\" | wc -l)\" #自启动服务数量\nreport_RuningService=\"$(echo \"$process\" | wc -l)\" #运行中服务数量\nfi\necho \"服务配置\"\necho \"--------\"\necho \"$conf\" | column -t\necho \"\"\necho \"正在运行的服务\"\necho \"--------------\"\necho \"$process\"\n\n}\n\n\nfunction getAutoStartStatus(){\necho \"\"\necho \"############################ 自启动检查 ##########################\"\nconf=$(grep -v \"^#\" /etc/rc.d/rc.local| sed '/^$/d')\necho \"$conf\"\n#报表信息\nreport_SelfInitiatedProgram=\"$(echo $conf | wc -l)\" #自启动程序数量\n}\n\nfunction getLoginStatus(){\necho \"\"\necho \"############################ 登录检查 ############################\"\nlast | head\n}\n\nfunction getNetworkStatus(){\necho \"\"\necho \"############################ 网络检查 ############################\"\nif [[ $centosVersion < 7 ]];then\n/sbin/ifconfig -a | grep -v packets | grep -v collisions | grep -v inet6\nelse\n#ip a\nfor i in $(ip link | grep BROADCAST | awk -F: '{print $2}');do ip add show $i | grep -E \"BROADCAST|global\"| awk '{print $2}' | tr '\\n' ' ' ;echo \"\" ;done\nfi\nGATEWAY=$(ip route | grep default | awk '{print $3}')\nDNS=$(grep nameserver /etc/resolv.conf| grep -v \"#\" | awk '{print $2}' | tr '\\n' ',' | sed 's/,$//')\necho \"$IP\"\necho \"网关：$GATEWAY \"\necho \" DNS：$DNS\"\n#报表信息\nIP=$(ip -f inet addr | grep -v 127.0.0.1 | grep inet | awk '{print $NF,$2}' | tr '\\n' ',' | sed 's/,$//')\nMAC=$(ip link | grep -v \"LOOPBACK\\|loopback\" | awk '{print $2}' | sed 'N;s/\\n//' | tr '\\n' ',' | sed 's/,$//')\nreport_IP=\"$IP\" #IP地址\nreport_MAC=$MAC #MAC地址\nreport_Gateway=\"$GATEWAY\" #默认网关\nreport_DNS=\"$DNS\" #DNS\n}\n\nfunction getListenStatus(){\necho \"\"\necho \"############################ 监听检查 ############################\"\nTCPListen=$(ss -ntul | column -t)\necho \"$TCPListen\"\n#报表信息\nreport_Listen=\"$(echo \"$TCPListen\"| sed '1d' | awk '/tcp/ {print $5}' | awk -F: '{print $NF}' | sort | uniq | wc -l)\"\n}\n\nfunction getCronStatus(){\necho \"\"\necho \"############################ 计划任务检查 ########################\"\nCrontab=0\nfor shell in $(grep -v \"/sbin/nologin\" /etc/shells);do\nfor user in $(grep \"$shell\" /etc/passwd| awk -F: '{print $1}');do\ncrontab -l -u $user >/dev/null 2>&1\nstatus=$?\nif [ $status -eq 0 ];then\necho \"$user\"\necho \"--------\"\ncrontab -l -u $user\nlet Crontab=Crontab+$(crontab -l -u $user | wc -l)\necho \"\"\nfi\ndone\ndone\n#计划任务\nfind /etc/cron* -type f | xargs -i ls -l {} | column -t\nlet Crontab=Crontab+$(find /etc/cron* -type f | wc -l)\n#报表信息\nreport_Crontab=\"$Crontab\" #计划任务数\n}\nfunction getHowLongAgo(){\n# 计算一个时间戳离现在有多久了\ndatetime=\"$*\"\n[ -z \"$datetime\" ] && echo \"错误的参数：getHowLongAgo() $*\"\nTimestamp=$(date +%s -d \"$datetime\") #转化为时间戳\nNow_Timestamp=$(date +%s)\nDifference_Timestamp=$(($Now_Timestamp-$Timestamp))\ndays=0;hours=0;minutes=0;\nsec_in_day=$((60*60*24));\nsec_in_hour=$((60*60));\nsec_in_minute=60\nwhile (( $(($Difference_Timestamp-$sec_in_day)) > 1 ))\ndo\nlet Difference_Timestamp=Difference_Timestamp-sec_in_day\nlet days++\ndone\nwhile (( $(($Difference_Timestamp-$sec_in_hour)) > 1 ))\ndo\nlet Difference_Timestamp=Difference_Timestamp-sec_in_hour\nlet hours++\ndone\necho \"$days 天 $hours 小时前\"\n}\n\nfunction getUserLastLogin(){\n# 获取用户最近一次登录的时间，含年份\n# 很遗憾last命令不支持显示年份，只有\"last -t YYYYMMDDHHMMSS\"表示某个时间之间的登录，我\n# 们只能用最笨的方法了，对比今天之前和今年元旦之前（或者去年之前和前年之前……）某个用户\n# 登录次数，如果登录统计次数有变化，则说明最近一次登录是今年。\nusername=$1\n: ${username:=\"`whoami`\"}\nthisYear=$(date +%Y)\noldesYear=$(last | tail -n1 | awk '{print $NF}')\nwhile(( $thisYear >= $oldesYear));do\nloginBeforeToday=$(last $username | grep $username | wc -l)\nloginBeforeNewYearsDayOfThisYear=$(last $username -t $thisYear\"0101000000\" | grep $username | wc -l)\nif [ $loginBeforeToday -eq 0 ];then\necho \"从未登录过\"\nbreak\nelif [ $loginBeforeToday -gt $loginBeforeNewYearsDayOfThisYear ];then\nlastDateTime=$(last -i $username | head -n1 | awk '{for(i=4;i<(NF-2);i++)printf\"%s \",$i}')\" $thisYear\" #格式如: Sat Nov 2 20:33 2015\nlastDateTime=$(date \"+%Y-%m-%d %H:%M:%S\" -d \"$lastDateTime\")\necho \"$lastDateTime\"\nbreak\nelse\nthisYear=$((thisYear-1))\nfi\ndone\n\n}\n\nfunction getUserStatus(){\necho \"\"\necho \"############################ 用户检查 ############################\"\n#/etc/passwd 最后修改时间\npwdfile=\"$(cat /etc/passwd)\"\nModify=$(stat /etc/passwd | grep Modify | tr '.' ' ' | awk '{print $2,$3}')\n\necho \"/etc/passwd 最后修改时间：$Modify ($(getHowLongAgo $Modify))\"\necho \"\"\necho \"特权用户\"\necho \"--------\"\nRootUser=\"\"\nfor user in $(echo \"$pwdfile\" | awk -F: '{print $1}');do\nif [ $(id -u $user) -eq 0 ];then\necho \"$user\"\nRootUser=\"$RootUser,$user\"\nfi\ndone\necho \"\"\necho \"用户列表\"\necho \"--------\"\nUSERs=0\necho \"$(\necho \"用户名 UID GID HOME SHELL 最后一次登录\"\nfor shell in $(grep -v \"/sbin/nologin\" /etc/shells);do\nfor username in $(grep \"$shell\" /etc/passwd| awk -F: '{print $1}');do\nuserLastLogin=\"$(getUserLastLogin $username)\"\necho \"$pwdfile\" | grep -w \"$username\" |grep -w \"$shell\"| awk -F: -v lastlogin=\"$(echo \"$userLastLogin\" | tr ' ' '_')\" '{print $1,$3,$4,$6,$7,lastlogin}'\ndone\nlet USERs=USERs+$(echo \"$pwdfile\" | grep \"$shell\"| wc -l)\ndone\n)\" | column -t\necho \"\"\necho \"空密码用户\"\necho \"----------\"\nUSEREmptyPassword=\"\"\nfor shell in $(grep -v \"/sbin/nologin\" /etc/shells);do\nfor user in $(echo \"$pwdfile\" | grep \"$shell\" | cut -d: -f1);do\nr=$(awk -F: '$2==\"!!\"{print $1}' /etc/shadow | grep -w $user)\nif [ ! -z $r ];then\necho $r\nUSEREmptyPassword=\"$USEREmptyPassword,\"$r\nfi\ndone\ndone\necho \"\"\necho \"相同ID的用户\"\necho \"------------\"\nUSERTheSameUID=\"\"\nUIDs=$(cut -d: -f3 /etc/passwd | sort | uniq -c | awk '$1>1{print $2}')\nfor uid in $UIDs;do\necho -n \"$uid\";\nUSERTheSameUID=\"$uid\"\nr=$(awk -F: 'ORS=\"\";$3=='\"$uid\"'{print \":\",$1}' /etc/passwd)\necho \"$r\"\necho \"\"\nUSERTheSameUID=\"$USERTheSameUID $r,\"\ndone\n#报表信息\nreport_USERs=\"$USERs\" #用户\nreport_USEREmptyPassword=$(echo $USEREmptyPassword | sed 's/^,//')\nreport_USERTheSameUID=$(echo $USERTheSameUID | sed 's/,$//')\nreport_RootUser=$(echo $RootUser | sed 's/^,//') #特权用户\n}\n\n\nfunction getPasswordStatus {\necho \"\"\necho \"############################ 密码检查 ############################\"\npwdfile=\"$(cat /etc/passwd)\"\necho \"\"\necho \"密码过期检查\"\necho \"------------\"\nresult=\"\"\nfor shell in $(grep -v \"/sbin/nologin\" /etc/shells);do\nfor user in $(echo \"$pwdfile\" | grep \"$shell\" | cut -d: -f1);do\nget_expiry_date=$(/usr/bin/chage -l $user | grep 'Password expires' | cut -d: -f2)\nif [[ $get_expiry_date = ' never' || $get_expiry_date = 'never' ]];then\nprintf \"%-15s 永不过期\\n\" $user\nresult=\"$result,$user:never\"\nelse\npassword_expiry_date=$(date -d \"$get_expiry_date\" \"+%s\")\ncurrent_date=$(date \"+%s\")\ndiff=$(($password_expiry_date-$current_date))\nlet DAYS=$(($diff/(60*60*24)))\nprintf \"%-15s %s天后过期\\n\" $user $DAYS\nresult=\"$result,$user:$DAYS days\"\nfi\ndone\ndone\nreport_PasswordExpiry=$(echo $result | sed 's/^,//')\n\necho \"\"\necho \"密码策略检查\"\necho \"------------\"\ngrep -v \"#\" /etc/login.defs | grep -E \"PASS_MAX_DAYS|PASS_MIN_DAYS|PASS_MIN_LEN|PASS_WARN_AGE\"\n\n\n}\n\nfunction getSudoersStatus(){\necho \"\"\necho \"############################ Sudoers检查 #########################\"\nconf=$(grep -v \"^#\" /etc/sudoers| grep -v \"^Defaults\" | sed '/^$/d')\necho \"$conf\"\necho \"\"\n#报表信息\nreport_Sudoers=\"$(echo $conf | wc -l)\"\n}\n\nfunction getInstalledStatus(){\necho \"\"\necho \"############################ 软件检查 ############################\"\nrpm -qa --last | head | column -t\n}\n\nfunction getProcessStatus(){\necho \"\"\necho \"############################ 进程检查 ############################\"\nif [ $(ps -ef | grep defunct | grep -v grep | wc -l) -ge 1 ];then\necho \"\"\necho \"僵尸进程\";\necho \"--------\"\nps -ef | head -n1\nps -ef | grep defunct | grep -v grep\nfi\necho \"\"\necho \"内存占用TOP10\"\necho \"-------------\"\necho -e \"PID %MEM RSS COMMAND\n$(ps aux | awk '{print $2, $4, $6, $11}' | sort -k3rn | head -n 10 )\"| column -t\necho \"\"\necho \"CPU占用TOP10\"\necho \"------------\"\ntop b -n1 | head -17 | tail -11\n#报表信息\nreport_DefunctProsess=\"$(ps -ef | grep defunct | grep -v grep|wc -l)\"\n}\n\nfunction getJDKStatus(){\necho \"\"\necho \"############################ JDK检查 #############################\"\njava -version 2>/dev/null\nif [ $? -eq 0 ];then\njava -version 2>&1\nfi\necho \"JAVA_HOME=\\\"$JAVA_HOME\\\"\"\n#报表信息\nreport_JDK=\"$(java -version 2>&1 | grep version | awk '{print $1,$3}' | tr -d '\"')\"\n}\nfunction getSyslogStatus(){\necho \"\"\necho \"############################ syslog检查 ##########################\"\necho \"服务状态：$(getState rsyslog)\"\necho \"\"\necho \"/etc/rsyslog.conf\"\necho \"-----------------\"\ncat /etc/rsyslog.conf 2>/dev/null | grep -v \"^#\" | grep -v \"^\\\\$\" | sed '/^$/d' | column -t\n#报表信息\nreport_Syslog=\"$(getState rsyslog)\"\n}\nfunction getFirewallStatus(){\necho \"\"\necho \"############################ 防火墙检查 ##########################\"\n#防火墙状态，策略等\nif [[ $centosVersion < 7 ]];then\n/etc/init.d/iptables status >/dev/null 2>&1\nstatus=$?\nif [ $status -eq 0 ];then\ns=\"active\"\nelif [ $status -eq 3 ];then\ns=\"inactive\"\nelif [ $status -eq 4 ];then\ns=\"permission denied\"\nelse\ns=\"unknown\"\nfi\nelse\ns=\"$(getState iptables)\"\nfi\necho \"iptables: $s\"\necho \"\"\necho \"/etc/sysconfig/iptables\"\necho \"-----------------------\"\ncat /etc/sysconfig/iptables 2>/dev/null\n#报表信息\nreport_Firewall=\"$s\"\n}\n\nfunction getSNMPStatus(){\n#SNMP服务状态，配置等\necho \"\"\necho \"############################ SNMP检查 ############################\"\nstatus=\"$(getState snmpd)\"\necho \"服务状态：$status\"\necho \"\"\nif [ -e /etc/snmp/snmpd.conf ];then\necho \"/etc/snmp/snmpd.conf\"\necho \"--------------------\"\ncat /etc/snmp/snmpd.conf 2>/dev/null | grep -v \"^#\" | sed '/^$/d'\nfi\n#报表信息\nreport_SNMP=\"$(getState snmpd)\"\n}\n\n\n\nfunction getState(){\nif [[ $centosVersion < 7 ]];then\nif [ -e \"/etc/init.d/$1\" ];then\nif [ `/etc/init.d/$1 status 2>/dev/null | grep -E \"is running|正在运行\" | wc -l` -ge 1 ];then\nr=\"active\"\nelse\nr=\"inactive\"\nfi\nelse\nr=\"unknown\"\nfi\nelse\n#CentOS 7+\nr=\"$(systemctl is-active $1 2>&1)\"\nfi\necho \"$r\"\n}\n\nfunction getSSHStatus(){\n#SSHD服务状态，配置,受信任主机等\necho \"\"\necho \"############################ SSH检查 #############################\"\n#检查受信任主机\npwdfile=\"$(cat /etc/passwd)\"\necho \"服务状态：$(getState sshd)\"\nProtocol_Version=$(cat /etc/ssh/sshd_config | grep Protocol | awk '{print $2}')\necho \"SSH协议版本：$Protocol_Version\"\necho \"\"\necho \"信任主机\"\necho \"--------\"\nauthorized=0\nfor user in $(echo \"$pwdfile\" | grep /bin/bash | awk -F: '{print $1}');do\nauthorize_file=$(echo \"$pwdfile\" | grep -w $user | awk -F: '{printf $6\"/.ssh/authorized_keys\"}')\nauthorized_host=$(cat $authorize_file 2>/dev/null | awk '{print $3}' | tr '\\n' ',' | sed 's/,$//')\nif [ ! -z $authorized_host ];then\necho \"$user 授权 \\\"$authorized_host\\\" 无密码访问\"\nfi\nlet authorized=authorized+$(cat $authorize_file 2>/dev/null | awk '{print $3}'|wc -l)\ndone\n\necho \"\"\necho \"是否允许ROOT远程登录\"\necho \"--------------------\"\nconfig=$(cat /etc/ssh/sshd_config | grep PermitRootLogin)\nfirstChar=${config:0:1}\nif [ $firstChar == \"#\" ];then\nPermitRootLogin=\"yes\" #默认是允许ROOT远程登录的\nelse\nPermitRootLogin=$(echo $config | awk '{print $2}')\nfi\necho \"PermitRootLogin $PermitRootLogin\"\n\necho \"\"\necho \"/etc/ssh/sshd_config\"\necho \"--------------------\"\ncat /etc/ssh/sshd_config | grep -v \"^#\" | sed '/^$/d'\n\n#报表信息\nreport_SSHAuthorized=\"$authorized\" #SSH信任主机\nreport_SSHDProtocolVersion=\"$Protocol_Version\" #SSH协议版本\nreport_SSHDPermitRootLogin=\"$PermitRootLogin\" #允许root远程登录\n}\nfunction getNTPStatus(){\n#NTP服务状态，当前时间，配置等\necho \"\"\necho \"\"\necho \"############################ NTP检查 #############################\"\nif [ -e /etc/ntp.conf ];then\necho \"服务状态：$(getState ntpd)\"\necho \"\"\necho \"/etc/ntp.conf\"\necho \"-------------\"\ncat /etc/ntp.conf 2>/dev/null | grep -v \"^#\" | sed '/^$/d'\nfi\n#报表信息\nreport_NTP=\"$(getState ntpd)\"\n}\n\n\nfunction uploadHostDailyCheckReport(){\njson=\"{\n\\\"DateTime\\\":\\\"$report_DateTime\\\",\n\\\"Hostname\\\":\\\"$report_Hostname\\\",\n\\\"OSRelease\\\":\\\"$report_OSRelease\\\",\n\\\"Kernel\\\":\\\"$report_Kernel\\\",\n\\\"Language\\\":\\\"$report_Language\\\",\n\\\"LastReboot\\\":\\\"$report_LastReboot\\\",\n\\\"Uptime\\\":\\\"$report_Uptime\\\",\n\\\"CPUs\\\":\\\"$report_CPUs\\\",\n\\\"CPUType\\\":\\\"$report_CPUType\\\",\n\\\"Arch\\\":\\\"$report_Arch\\\",\n\\\"MemTotal\\\":\\\"$report_MemTotal\\\",\n\\\"MemFree\\\":\\\"$report_MemFree\\\",\n\\\"MemUsedPercent\\\":\\\"$report_MemUsedPercent\\\",\n\\\"DiskTotal\\\":\\\"$report_DiskTotal\\\",\n\\\"DiskFree\\\":\\\"$report_DiskFree\\\",\n\\\"DiskUsedPercent\\\":\\\"$report_DiskUsedPercent\\\",\n\\\"InodeTotal\\\":\\\"$report_InodeTotal\\\",\n\\\"InodeFree\\\":\\\"$report_InodeFree\\\",\n\\\"InodeUsedPercent\\\":\\\"$report_InodeUsedPercent\\\",\n\\\"IP\\\":\\\"$report_IP\\\",\n\\\"MAC\\\":\\\"$report_MAC\\\",\n\\\"Gateway\\\":\\\"$report_Gateway\\\",\n\\\"DNS\\\":\\\"$report_DNS\\\",\n\\\"Listen\\\":\\\"$report_Listen\\\",\n\\\"Selinux\\\":\\\"$report_Selinux\\\",\n\\\"Firewall\\\":\\\"$report_Firewall\\\",\n\\\"USERs\\\":\\\"$report_USERs\\\",\n\\\"USEREmptyPassword\\\":\\\"$report_USEREmptyPassword\\\",\n\\\"USERTheSameUID\\\":\\\"$report_USERTheSameUID\\\",\n\\\"PasswordExpiry\\\":\\\"$report_PasswordExpiry\\\",\n\\\"RootUser\\\":\\\"$report_RootUser\\\",\n\\\"Sudoers\\\":\\\"$report_Sudoers\\\",\n\\\"SSHAuthorized\\\":\\\"$report_SSHAuthorized\\\",\n\\\"SSHDProtocolVersion\\\":\\\"$report_SSHDProtocolVersion\\\",\n\\\"SSHDPermitRootLogin\\\":\\\"$report_SSHDPermitRootLogin\\\",\n\\\"DefunctProsess\\\":\\\"$report_DefunctProsess\\\",\n\\\"SelfInitiatedService\\\":\\\"$report_SelfInitiatedService\\\",\n\\\"SelfInitiatedProgram\\\":\\\"$report_SelfInitiatedProgram\\\",\n\\\"RuningService\\\":\\\"$report_RuningService\\\",\n\\\"Crontab\\\":\\\"$report_Crontab\\\",\n\\\"Syslog\\\":\\\"$report_Syslog\\\",\n\\\"SNMP\\\":\\\"$report_SNMP\\\",\n\\\"NTP\\\":\\\"$report_NTP\\\",\n}\"\n#echo \"$json\"\ncurl -l -H \"Content-type: application/json\" -X POST -d \"$json\" \"$uploadHostDailyCheckReportApi\" 2>/dev/null\n}\n\nfunction getchage_file_24h()\n{\necho \"############################ 文件检查 #############################\"\n    check2=$(find / -name '*.sh' -mtime -1)\ncheck21=$(find / -name '*.asp' -mtime -1)\ncheck22=$(find / -name '*.php' -mtime -1)\ncheck23=$(find / -name '*.aspx' -mtime -1)\ncheck24=$(find / -name '*.jsp' -mtime -1)\ncheck25=$(find / -name '*.html' -mtime -1)\ncheck26=$(find / -name '*.htm' -mtime -1)\ncheck9=$(find / -name core -exec ls -l {} \\;)\ncheck10=$(cat /etc/crontab)\ncheck12=$(ls -alt /usr/bin | head -10)\ncat <<EOF\n\n############################查看所有被修改过的文件返回最近24小时内的############################\n${check2}\n${check21}\n${check22}\n${check23}\n${check24}\n${check25}\n${check26}\n${line}\n\n############################检查定时文件的完整性############################\n${check10}\n${line}\n\n############################查看系统命令是否被替换############################\n${check12}\n${line}\nEOF\n}\n\nfunction check(){\nversion\ngetSystemStatus\ngetCpuStatus\ngetMemStatus\ngetDiskStatus\ngetNetworkStatus\ngetListenStatus\ngetProcessStatus\ngetServiceStatus\ngetAutoStartStatus\ngetLoginStatus\ngetCronStatus\ngetUserStatus\ngetPasswordStatus\ngetSudoersStatus\ngetJDKStatus\ngetFirewallStatus\ngetSSHStatus\ngetSyslogStatus\ngetSNMPStatus\ngetNTPStatus\ngetInstalledStatus\ngetchage_file_24h\n}\n\n\n#执行检查并保存检查结果\ncheck > $RESULTFILE\n\necho \"检查结果：$RESULTFILE\"\necho -e \"`date \"+%Y-%m-%d %H:%M:%S\"` Host patrol inspection报告\"  | mail -a $RESULTFILE -s \"Host patrol inspection报告\" 1950974755@qq.com\n\nEND\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n\n\n> 本文作者：许怀安\n> 创作时间：2022.02.12\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "#!/bin/bash\n# @author: 许怀安\n# @date:   2022-02-12\n# @e-mail: 1950974755@qq.com\n#主机信息每日巡检\n\nipaddr=$(ifconfig |grep 'inet addr'|awk -f '[ :]' '{print $13}')\n#环境变量path没设好，在cron里执行时有很多命令会找不到\nexport path=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin\nsource /etc/profile\n\n[ $(id -u) -gt 0 ] && echo \"请用root用户执行此脚本！\" && exit 1\ncentosversion=$(awk '{print $(nf-1)}' /etc/redhat-release)\nversion=\"2021-12-17\"\n\n#日志相关\nprogpath=`echo $0 | sed -e 's,[\\\\/][^\\\\/][^\\\\/]*$,,'`\n[ -f $progpath ] && progpath=\".\"\nlogpath=\"$progpath/log\"\n[ -e $logpath ] || mkdir $logpath\nresultfile=\"$logpath/host_patrol_inspection-`date +%y%m%d`.txt\"\n\n#定义报表的全局变量\nreport_datetime=\"\" #日期 ok\nreport_hostname=\"\" #主机名 ok\nreport_osrelease=\"\" #发行版本 ok\nreport_kernel=\"\" #内核 ok\nreport_language=\"\" #语言/编码 ok\nreport_lastreboot=\"\" #最近启动时间 ok\nreport_uptime=\"\" #运行时间（天） ok\nreport_cpus=\"\" #cpu数量 ok\nreport_cputype=\"\" #cpu类型 ok\nreport_arch=\"\" #cpu架构 ok\nreport_memtotal=\"\" #内存总容量(mb) ok\nreport_memfree=\"\" #内存剩余(mb) ok\nreport_memusedpercent=\"\" #内存使用率% ok\nreport_disktotal=\"\" #硬盘总容量(gb) ok\nreport_diskfree=\"\" #硬盘剩余(gb) ok\nreport_diskusedpercent=\"\" #硬盘使用率% ok\nreport_inodetotal=\"\" #inode总量 ok\nreport_inodefree=\"\" #inode剩余 ok\nreport_inodeusedpercent=\"\" #inode使用率 ok\nreport_ip=\"\" #ip地址 ok\nreport_mac=\"\" #mac地址 ok\nreport_gateway=\"\" #默认网关 ok\nreport_dns=\"\" #dns ok\nreport_listen=\"\" #监听 ok\nreport_selinux=\"\" #selinux ok\nreport_firewall=\"\" #防火墙 ok\nreport_users=\"\" #用户 ok\nreport_useremptypassword=\"\" #空密码用户 ok\nreport_userthesameuid=\"\" #相同id的用户 ok\nreport_passwordexpiry=\"\" #密码过期（天） ok\nreport_rootuser=\"\" #root用户 ok\nreport_sudoers=\"\" #sudo授权 ok\nreport_sshauthorized=\"\" #ssh信任主机 ok\nreport_sshdprotocolversion=\"\" #ssh协议版本 ok\nreport_sshdpermitrootlogin=\"\" #允许root远程登录 ok\nreport_defunctprosess=\"\" #僵尸进程数量 ok\nreport_selfinitiatedservice=\"\" #自启动服务数量 ok\nreport_selfinitiatedprogram=\"\" #自启动程序数量 ok\nreport_runingservice=\"\" #运行中服务数 ok\nreport_crontab=\"\" #计划任务数 ok\nreport_syslog=\"\" #日志服务 ok\nreport_snmp=\"\" #snmp ok\nreport_ntp=\"\" #ntp ok\nfunction version(){\necho \"系统巡检脚本：version $version\"\n}\n\nfunction getcpustatus(){\necho \"\"\necho \"############################ cpu检查 #############################\"\nphysical_cpus=$(grep \"physical id\" /proc/cpuinfo| sort | uniq | wc -l)\nvirt_cpus=$(grep \"processor\" /proc/cpuinfo | wc -l)\ncpu_kernels=$(grep \"cores\" /proc/cpuinfo|uniq| awk -f ': ' '{print $2}')\ncpu_type=$(grep \"model name\" /proc/cpuinfo | awk -f ': ' '{print $2}' | sort | uniq)\ncpu_arch=$(uname -m)\necho \"物理cpu个数:$physical_cpus\"\necho \"逻辑cpu个数:$virt_cpus\"\necho \"每cpu核心数:$cpu_kernels\"\necho \" cpu型号:$cpu_type\"\necho \" cpu架构:$cpu_arch\"\n#报表信息\nreport_cpus=$virt_cpus #cpu数量\nreport_cputype=$cpu_type #cpu类型\nreport_arch=$cpu_arch #cpu架构\n}\n\nfunction getmemstatus(){\necho \"\"\necho \"############################ 内存检查 ############################\"\nif [[ $centosversion < 7 ]];then\nfree -mo\nelse\nfree -h\nfi\n#报表信息\nmemtotal=$(grep memtotal /proc/meminfo| awk '{print $2}') #kb\nmemfree=$(grep memfree /proc/meminfo| awk '{print $2}') #kb\nlet memused=memtotal-memfree\nmempercent=$(awk \"begin {if($memtotal==0){printf 100}else{printf \\\"%.2f\\\",$memused*100/$memtotal}}\")\nreport_memtotal=\"$((memtotal/1024))\"\"mb\" #内存总容量(mb)\nreport_memfree=\"$((memfree/1024))\"\"mb\" #内存剩余(mb)\nreport_memusedpercent=\"$(awk \"begin {if($memtotal==0){printf 100}else{printf \\\"%.2f\\\",$memused*100/$memtotal}}\")\"\"%\" #内存使用率%\n}\nfunction getdiskstatus(){\necho \"\"\necho \"############################ 磁盘检查 ############################\"\ndf -hip | sed 's/mounted on/mounted/'> /tmp/inode\ndf -htp | sed 's/mounted on/mounted/'> /tmp/disk\njoin /tmp/disk /tmp/inode | awk '{print $1,$2,\"|\",$3,$4,$5,$6,\"|\",$8,$9,$10,$11,\"|\",$12}'| column -t\n#报表信息\ndiskdata=$(df -tp | sed '1d' | awk '$2!=\"tmpfs\"{print}') #kb\ndisktotal=$(echo \"$diskdata\" | awk '{total+=$3}end{print total}') #kb\ndiskused=$(echo \"$diskdata\" | awk '{total+=$4}end{print total}') #kb\ndiskfree=$((disktotal-diskused)) #kb\ndiskusedpercent=$(echo $disktotal $diskused | awk '{if($1==0){printf 100}else{printf \"%.2f\",$2*100/$1}}')\ninodedata=$(df -itp | sed '1d' | awk '$2!=\"tmpfs\"{print}')\ninodetotal=$(echo \"$inodedata\" | awk '{total+=$3}end{print total}')\ninodeused=$(echo \"$inodedata\" | awk '{total+=$4}end{print total}')\ninodefree=$((inodetotal-inodeused))\ninodeusedpercent=$(echo $inodetotal $inodeused | awk '{if($1==0){printf 100}else{printf \"%.2f\",$2*100/$1}}')\nreport_disktotal=$((disktotal/1024/1024))\"gb\" #硬盘总容量(gb)\nreport_diskfree=$((diskfree/1024/1024))\"gb\" #硬盘剩余(gb)\nreport_diskusedpercent=\"$diskusedpercent\"\"%\" #硬盘使用率%\nreport_inodetotal=$((inodetotal/1000))\"k\" #inode总量\nreport_inodefree=$((inodefree/1000))\"k\" #inode剩余\nreport_inodeusedpercent=\"$inodeusedpercent\"\"%\" #inode使用率%\n\n}\n\nfunction getsystemstatus(){\necho \"\"\necho \"############################ 系统检查 ############################\"\nif [ -e /etc/sysconfig/i18n ];then\ndefault_lang=\"$(grep \"lang=\" /etc/sysconfig/i18n | grep -v \"^#\" | awk -f '\"' '{print $2}')\"\nelse\ndefault_lang=$lang\nfi\nexport lang=\"en_us.utf-8\"\nrelease=$(cat /etc/redhat-release 2>/dev/null)\nkernel=$(uname -r)\nos=$(uname -o)\nhostname=$(uname -n)\nselinux=$(/usr/sbin/sestatus | grep \"selinux status: \" | awk '{print $3}')\nlastreboot=$(who -b | awk '{print $3,$4}')\nuptime=$(uptime | sed 's/.*up \\([^,]*\\), .*/\\1/')\necho \" 系统：$os\"\necho \" 发行版本：$release\"\necho \" 内核：$kernel\"\necho \" 主机名：$hostname\"\necho \" selinux：$selinux\"\necho \"语言/编码：$default_lang\"\necho \" 当前时间：$(date +'%f %t')\"\necho \" 最后启动：$lastreboot\"\necho \" 运行时间：$uptime\"\n#报表信息\nreport_datetime=$(date +\"%f %t\") #日期\nreport_hostname=\"$hostname\" #主机名\nreport_osrelease=\"$release\" #发行版本\nreport_kernel=\"$kernel\" #内核\nreport_language=\"$default_lang\" #语言/编码\nreport_lastreboot=\"$lastreboot\" #最近启动时间\nreport_uptime=\"$uptime\" #运行时间（天）\nreport_selinux=\"$selinux\"\nexport lang=\"$default_lang\"\n\n}\n\nfunction getservicestatus(){\necho \"\"\necho \"############################ 服务检查 ############################\"\necho \"\"\nif [[ $centosversion > 7 ]];then\nconf=$(systemctl list-unit-files --type=service --state=enabled --no-pager | grep \"enabled\")\nprocess=$(systemctl list-units --type=service --state=running --no-pager | grep \".service\")\n#报表信息\nreport_selfinitiatedservice=\"$(echo \"$conf\" | wc -l)\" #自启动服务数量\nreport_runingservice=\"$(echo \"$process\" | wc -l)\" #运行中服务数量\nelse\nconf=$(/sbin/chkconfig | grep -e \":on|:启用\")\nprocess=$(/sbin/service --status-all 2>/dev/null | grep -e \"is running|正在运行\")\n#报表信息\nreport_selfinitiatedservice=\"$(echo \"$conf\" | wc -l)\" #自启动服务数量\nreport_runingservice=\"$(echo \"$process\" | wc -l)\" #运行中服务数量\nfi\necho \"服务配置\"\necho \"--------\"\necho \"$conf\" | column -t\necho \"\"\necho \"正在运行的服务\"\necho \"--------------\"\necho \"$process\"\n\n}\n\n\nfunction getautostartstatus(){\necho \"\"\necho \"############################ 自启动检查 ##########################\"\nconf=$(grep -v \"^#\" /etc/rc.d/rc.local| sed '/^$/d')\necho \"$conf\"\n#报表信息\nreport_selfinitiatedprogram=\"$(echo $conf | wc -l)\" #自启动程序数量\n}\n\nfunction getloginstatus(){\necho \"\"\necho \"############################ 登录检查 ############################\"\nlast | head\n}\n\nfunction getnetworkstatus(){\necho \"\"\necho \"############################ 网络检查 ############################\"\nif [[ $centosversion < 7 ]];then\n/sbin/ifconfig -a | grep -v packets | grep -v collisions | grep -v inet6\nelse\n#ip a\nfor i in $(ip link | grep broadcast | awk -f: '{print $2}');do ip add show $i | grep -e \"broadcast|global\"| awk '{print $2}' | tr '\\n' ' ' ;echo \"\" ;done\nfi\ngateway=$(ip route | grep default | awk '{print $3}')\ndns=$(grep nameserver /etc/resolv.conf| grep -v \"#\" | awk '{print $2}' | tr '\\n' ',' | sed 's/,$//')\necho \"$ip\"\necho \"网关：$gateway \"\necho \" dns：$dns\"\n#报表信息\nip=$(ip -f inet addr | grep -v 127.0.0.1 | grep inet | awk '{print $nf,$2}' | tr '\\n' ',' | sed 's/,$//')\nmac=$(ip link | grep -v \"loopback\\|loopback\" | awk '{print $2}' | sed 'n;s/\\n//' | tr '\\n' ',' | sed 's/,$//')\nreport_ip=\"$ip\" #ip地址\nreport_mac=$mac #mac地址\nreport_gateway=\"$gateway\" #默认网关\nreport_dns=\"$dns\" #dns\n}\n\nfunction getlistenstatus(){\necho \"\"\necho \"############################ 监听检查 ############################\"\ntcplisten=$(ss -ntul | column -t)\necho \"$tcplisten\"\n#报表信息\nreport_listen=\"$(echo \"$tcplisten\"| sed '1d' | awk '/tcp/ {print $5}' | awk -f: '{print $nf}' | sort | uniq | wc -l)\"\n}\n\nfunction getcronstatus(){\necho \"\"\necho \"############################ 计划任务检查 ########################\"\ncrontab=0\nfor shell in $(grep -v \"/sbin/nologin\" /etc/shells);do\nfor user in $(grep \"$shell\" /etc/passwd| awk -f: '{print $1}');do\ncrontab -l -u $user >/dev/null 2>&1\nstatus=$?\nif [ $status -eq 0 ];then\necho \"$user\"\necho \"--------\"\ncrontab -l -u $user\nlet crontab=crontab+$(crontab -l -u $user | wc -l)\necho \"\"\nfi\ndone\ndone\n#计划任务\nfind /etc/cron* -type f | xargs -i ls -l {} | column -t\nlet crontab=crontab+$(find /etc/cron* -type f | wc -l)\n#报表信息\nreport_crontab=\"$crontab\" #计划任务数\n}\nfunction gethowlongago(){\n# 计算一个时间戳离现在有多久了\ndatetime=\"$*\"\n[ -z \"$datetime\" ] && echo \"错误的参数：gethowlongago() $*\"\ntimestamp=$(date +%s -d \"$datetime\") #转化为时间戳\nnow_timestamp=$(date +%s)\ndifference_timestamp=$(($now_timestamp-$timestamp))\ndays=0;hours=0;minutes=0;\nsec_in_day=$((60*60*24));\nsec_in_hour=$((60*60));\nsec_in_minute=60\nwhile (( $(($difference_timestamp-$sec_in_day)) > 1 ))\ndo\nlet difference_timestamp=difference_timestamp-sec_in_day\nlet days++\ndone\nwhile (( $(($difference_timestamp-$sec_in_hour)) > 1 ))\ndo\nlet difference_timestamp=difference_timestamp-sec_in_hour\nlet hours++\ndone\necho \"$days 天 $hours 小时前\"\n}\n\nfunction getuserlastlogin(){\n# 获取用户最近一次登录的时间，含年份\n# 很遗憾last命令不支持显示年份，只有\"last -t yyyymmddhhmmss\"表示某个时间之间的登录，我\n# 们只能用最笨的方法了，对比今天之前和今年元旦之前（或者去年之前和前年之前……）某个用户\n# 登录次数，如果登录统计次数有变化，则说明最近一次登录是今年。\nusername=$1\n: ${username:=\"`whoami`\"}\nthisyear=$(date +%y)\noldesyear=$(last | tail -n1 | awk '{print $nf}')\nwhile(( $thisyear >= $oldesyear));do\nloginbeforetoday=$(last $username | grep $username | wc -l)\nloginbeforenewyearsdayofthisyear=$(last $username -t $thisyear\"0101000000\" | grep $username | wc -l)\nif [ $loginbeforetoday -eq 0 ];then\necho \"从未登录过\"\nbreak\nelif [ $loginbeforetoday -gt $loginbeforenewyearsdayofthisyear ];then\nlastdatetime=$(last -i $username | head -n1 | awk '{for(i=4;i<(nf-2);i++)printf\"%s \",$i}')\" $thisyear\" #格式如: sat nov 2 20:33 2015\nlastdatetime=$(date \"+%y-%m-%d %h:%m:%s\" -d \"$lastdatetime\")\necho \"$lastdatetime\"\nbreak\nelse\nthisyear=$((thisyear-1))\nfi\ndone\n\n}\n\nfunction getuserstatus(){\necho \"\"\necho \"############################ 用户检查 ############################\"\n#/etc/passwd 最后修改时间\npwdfile=\"$(cat /etc/passwd)\"\nmodify=$(stat /etc/passwd | grep modify | tr '.' ' ' | awk '{print $2,$3}')\n\necho \"/etc/passwd 最后修改时间：$modify ($(gethowlongago $modify))\"\necho \"\"\necho \"特权用户\"\necho \"--------\"\nrootuser=\"\"\nfor user in $(echo \"$pwdfile\" | awk -f: '{print $1}');do\nif [ $(id -u $user) -eq 0 ];then\necho \"$user\"\nrootuser=\"$rootuser,$user\"\nfi\ndone\necho \"\"\necho \"用户列表\"\necho \"--------\"\nusers=0\necho \"$(\necho \"用户名 uid gid home shell 最后一次登录\"\nfor shell in $(grep -v \"/sbin/nologin\" /etc/shells);do\nfor username in $(grep \"$shell\" /etc/passwd| awk -f: '{print $1}');do\nuserlastlogin=\"$(getuserlastlogin $username)\"\necho \"$pwdfile\" | grep -w \"$username\" |grep -w \"$shell\"| awk -f: -v lastlogin=\"$(echo \"$userlastlogin\" | tr ' ' '_')\" '{print $1,$3,$4,$6,$7,lastlogin}'\ndone\nlet users=users+$(echo \"$pwdfile\" | grep \"$shell\"| wc -l)\ndone\n)\" | column -t\necho \"\"\necho \"空密码用户\"\necho \"----------\"\nuseremptypassword=\"\"\nfor shell in $(grep -v \"/sbin/nologin\" /etc/shells);do\nfor user in $(echo \"$pwdfile\" | grep \"$shell\" | cut -d: -f1);do\nr=$(awk -f: '$2==\"!!\"{print $1}' /etc/shadow | grep -w $user)\nif [ ! -z $r ];then\necho $r\nuseremptypassword=\"$useremptypassword,\"$r\nfi\ndone\ndone\necho \"\"\necho \"相同id的用户\"\necho \"------------\"\nuserthesameuid=\"\"\nuids=$(cut -d: -f3 /etc/passwd | sort | uniq -c | awk '$1>1{print $2}')\nfor uid in $uids;do\necho -n \"$uid\";\nuserthesameuid=\"$uid\"\nr=$(awk -f: 'ors=\"\";$3=='\"$uid\"'{print \":\",$1}' /etc/passwd)\necho \"$r\"\necho \"\"\nuserthesameuid=\"$userthesameuid $r,\"\ndone\n#报表信息\nreport_users=\"$users\" #用户\nreport_useremptypassword=$(echo $useremptypassword | sed 's/^,//')\nreport_userthesameuid=$(echo $userthesameuid | sed 's/,$//')\nreport_rootuser=$(echo $rootuser | sed 's/^,//') #特权用户\n}\n\n\nfunction getpasswordstatus {\necho \"\"\necho \"############################ 密码检查 ############################\"\npwdfile=\"$(cat /etc/passwd)\"\necho \"\"\necho \"密码过期检查\"\necho \"------------\"\nresult=\"\"\nfor shell in $(grep -v \"/sbin/nologin\" /etc/shells);do\nfor user in $(echo \"$pwdfile\" | grep \"$shell\" | cut -d: -f1);do\nget_expiry_date=$(/usr/bin/chage -l $user | grep 'password expires' | cut -d: -f2)\nif [[ $get_expiry_date = ' never' || $get_expiry_date = 'never' ]];then\nprintf \"%-15s 永不过期\\n\" $user\nresult=\"$result,$user:never\"\nelse\npassword_expiry_date=$(date -d \"$get_expiry_date\" \"+%s\")\ncurrent_date=$(date \"+%s\")\ndiff=$(($password_expiry_date-$current_date))\nlet days=$(($diff/(60*60*24)))\nprintf \"%-15s %s天后过期\\n\" $user $days\nresult=\"$result,$user:$days days\"\nfi\ndone\ndone\nreport_passwordexpiry=$(echo $result | sed 's/^,//')\n\necho \"\"\necho \"密码策略检查\"\necho \"------------\"\ngrep -v \"#\" /etc/login.defs | grep -e \"pass_max_days|pass_min_days|pass_min_len|pass_warn_age\"\n\n\n}\n\nfunction getsudoersstatus(){\necho \"\"\necho \"############################ sudoers检查 #########################\"\nconf=$(grep -v \"^#\" /etc/sudoers| grep -v \"^defaults\" | sed '/^$/d')\necho \"$conf\"\necho \"\"\n#报表信息\nreport_sudoers=\"$(echo $conf | wc -l)\"\n}\n\nfunction getinstalledstatus(){\necho \"\"\necho \"############################ 软件检查 ############################\"\nrpm -qa --last | head | column -t\n}\n\nfunction getprocessstatus(){\necho \"\"\necho \"############################ 进程检查 ############################\"\nif [ $(ps -ef | grep defunct | grep -v grep | wc -l) -ge 1 ];then\necho \"\"\necho \"僵尸进程\";\necho \"--------\"\nps -ef | head -n1\nps -ef | grep defunct | grep -v grep\nfi\necho \"\"\necho \"内存占用top10\"\necho \"-------------\"\necho -e \"pid %mem rss command\n$(ps aux | awk '{print $2, $4, $6, $11}' | sort -k3rn | head -n 10 )\"| column -t\necho \"\"\necho \"cpu占用top10\"\necho \"------------\"\ntop b -n1 | head -17 | tail -11\n#报表信息\nreport_defunctprosess=\"$(ps -ef | grep defunct | grep -v grep|wc -l)\"\n}\n\nfunction getjdkstatus(){\necho \"\"\necho \"############################ jdk检查 #############################\"\njava -version 2>/dev/null\nif [ $? -eq 0 ];then\njava -version 2>&1\nfi\necho \"java_home=\\\"$java_home\\\"\"\n#报表信息\nreport_jdk=\"$(java -version 2>&1 | grep version | awk '{print $1,$3}' | tr -d '\"')\"\n}\nfunction getsyslogstatus(){\necho \"\"\necho \"############################ syslog检查 ##########################\"\necho \"服务状态：$(getstate rsyslog)\"\necho \"\"\necho \"/etc/rsyslog.conf\"\necho \"-----------------\"\ncat /etc/rsyslog.conf 2>/dev/null | grep -v \"^#\" | grep -v \"^\\\\$\" | sed '/^$/d' | column -t\n#报表信息\nreport_syslog=\"$(getstate rsyslog)\"\n}\nfunction getfirewallstatus(){\necho \"\"\necho \"############################ 防火墙检查 ##########################\"\n#防火墙状态，策略等\nif [[ $centosversion < 7 ]];then\n/etc/init.d/iptables status >/dev/null 2>&1\nstatus=$?\nif [ $status -eq 0 ];then\ns=\"active\"\nelif [ $status -eq 3 ];then\ns=\"inactive\"\nelif [ $status -eq 4 ];then\ns=\"permission denied\"\nelse\ns=\"unknown\"\nfi\nelse\ns=\"$(getstate iptables)\"\nfi\necho \"iptables: $s\"\necho \"\"\necho \"/etc/sysconfig/iptables\"\necho \"-----------------------\"\ncat /etc/sysconfig/iptables 2>/dev/null\n#报表信息\nreport_firewall=\"$s\"\n}\n\nfunction getsnmpstatus(){\n#snmp服务状态，配置等\necho \"\"\necho \"############################ snmp检查 ############################\"\nstatus=\"$(getstate snmpd)\"\necho \"服务状态：$status\"\necho \"\"\nif [ -e /etc/snmp/snmpd.conf ];then\necho \"/etc/snmp/snmpd.conf\"\necho \"--------------------\"\ncat /etc/snmp/snmpd.conf 2>/dev/null | grep -v \"^#\" | sed '/^$/d'\nfi\n#报表信息\nreport_snmp=\"$(getstate snmpd)\"\n}\n\n\n\nfunction getstate(){\nif [[ $centosversion < 7 ]];then\nif [ -e \"/etc/init.d/$1\" ];then\nif [ `/etc/init.d/$1 status 2>/dev/null | grep -e \"is running|正在运行\" | wc -l` -ge 1 ];then\nr=\"active\"\nelse\nr=\"inactive\"\nfi\nelse\nr=\"unknown\"\nfi\nelse\n#centos 7+\nr=\"$(systemctl is-active $1 2>&1)\"\nfi\necho \"$r\"\n}\n\nfunction getsshstatus(){\n#sshd服务状态，配置,受信任主机等\necho \"\"\necho \"############################ ssh检查 #############################\"\n#检查受信任主机\npwdfile=\"$(cat /etc/passwd)\"\necho \"服务状态：$(getstate sshd)\"\nprotocol_version=$(cat /etc/ssh/sshd_config | grep protocol | awk '{print $2}')\necho \"ssh协议版本：$protocol_version\"\necho \"\"\necho \"信任主机\"\necho \"--------\"\nauthorized=0\nfor user in $(echo \"$pwdfile\" | grep /bin/bash | awk -f: '{print $1}');do\nauthorize_file=$(echo \"$pwdfile\" | grep -w $user | awk -f: '{printf $6\"/.ssh/authorized_keys\"}')\nauthorized_host=$(cat $authorize_file 2>/dev/null | awk '{print $3}' | tr '\\n' ',' | sed 's/,$//')\nif [ ! -z $authorized_host ];then\necho \"$user 授权 \\\"$authorized_host\\\" 无密码访问\"\nfi\nlet authorized=authorized+$(cat $authorize_file 2>/dev/null | awk '{print $3}'|wc -l)\ndone\n\necho \"\"\necho \"是否允许root远程登录\"\necho \"--------------------\"\nconfig=$(cat /etc/ssh/sshd_config | grep permitrootlogin)\nfirstchar=${config:0:1}\nif [ $firstchar == \"#\" ];then\npermitrootlogin=\"yes\" #默认是允许root远程登录的\nelse\npermitrootlogin=$(echo $config | awk '{print $2}')\nfi\necho \"permitrootlogin $permitrootlogin\"\n\necho \"\"\necho \"/etc/ssh/sshd_config\"\necho \"--------------------\"\ncat /etc/ssh/sshd_config | grep -v \"^#\" | sed '/^$/d'\n\n#报表信息\nreport_sshauthorized=\"$authorized\" #ssh信任主机\nreport_sshdprotocolversion=\"$protocol_version\" #ssh协议版本\nreport_sshdpermitrootlogin=\"$permitrootlogin\" #允许root远程登录\n}\nfunction getntpstatus(){\n#ntp服务状态，当前时间，配置等\necho \"\"\necho \"\"\necho \"############################ ntp检查 #############################\"\nif [ -e /etc/ntp.conf ];then\necho \"服务状态：$(getstate ntpd)\"\necho \"\"\necho \"/etc/ntp.conf\"\necho \"-------------\"\ncat /etc/ntp.conf 2>/dev/null | grep -v \"^#\" | sed '/^$/d'\nfi\n#报表信息\nreport_ntp=\"$(getstate ntpd)\"\n}\n\n\nfunction uploadhostdailycheckreport(){\njson=\"{\n\\\"datetime\\\":\\\"$report_datetime\\\",\n\\\"hostname\\\":\\\"$report_hostname\\\",\n\\\"osrelease\\\":\\\"$report_osrelease\\\",\n\\\"kernel\\\":\\\"$report_kernel\\\",\n\\\"language\\\":\\\"$report_language\\\",\n\\\"lastreboot\\\":\\\"$report_lastreboot\\\",\n\\\"uptime\\\":\\\"$report_uptime\\\",\n\\\"cpus\\\":\\\"$report_cpus\\\",\n\\\"cputype\\\":\\\"$report_cputype\\\",\n\\\"arch\\\":\\\"$report_arch\\\",\n\\\"memtotal\\\":\\\"$report_memtotal\\\",\n\\\"memfree\\\":\\\"$report_memfree\\\",\n\\\"memusedpercent\\\":\\\"$report_memusedpercent\\\",\n\\\"disktotal\\\":\\\"$report_disktotal\\\",\n\\\"diskfree\\\":\\\"$report_diskfree\\\",\n\\\"diskusedpercent\\\":\\\"$report_diskusedpercent\\\",\n\\\"inodetotal\\\":\\\"$report_inodetotal\\\",\n\\\"inodefree\\\":\\\"$report_inodefree\\\",\n\\\"inodeusedpercent\\\":\\\"$report_inodeusedpercent\\\",\n\\\"ip\\\":\\\"$report_ip\\\",\n\\\"mac\\\":\\\"$report_mac\\\",\n\\\"gateway\\\":\\\"$report_gateway\\\",\n\\\"dns\\\":\\\"$report_dns\\\",\n\\\"listen\\\":\\\"$report_listen\\\",\n\\\"selinux\\\":\\\"$report_selinux\\\",\n\\\"firewall\\\":\\\"$report_firewall\\\",\n\\\"users\\\":\\\"$report_users\\\",\n\\\"useremptypassword\\\":\\\"$report_useremptypassword\\\",\n\\\"userthesameuid\\\":\\\"$report_userthesameuid\\\",\n\\\"passwordexpiry\\\":\\\"$report_passwordexpiry\\\",\n\\\"rootuser\\\":\\\"$report_rootuser\\\",\n\\\"sudoers\\\":\\\"$report_sudoers\\\",\n\\\"sshauthorized\\\":\\\"$report_sshauthorized\\\",\n\\\"sshdprotocolversion\\\":\\\"$report_sshdprotocolversion\\\",\n\\\"sshdpermitrootlogin\\\":\\\"$report_sshdpermitrootlogin\\\",\n\\\"defunctprosess\\\":\\\"$report_defunctprosess\\\",\n\\\"selfinitiatedservice\\\":\\\"$report_selfinitiatedservice\\\",\n\\\"selfinitiatedprogram\\\":\\\"$report_selfinitiatedprogram\\\",\n\\\"runingservice\\\":\\\"$report_runingservice\\\",\n\\\"crontab\\\":\\\"$report_crontab\\\",\n\\\"syslog\\\":\\\"$report_syslog\\\",\n\\\"snmp\\\":\\\"$report_snmp\\\",\n\\\"ntp\\\":\\\"$report_ntp\\\",\n}\"\n#echo \"$json\"\ncurl -l -h \"content-type: application/json\" -x post -d \"$json\" \"$uploadhostdailycheckreportapi\" 2>/dev/null\n}\n\nfunction getchage_file_24h()\n{\necho \"############################ 文件检查 #############################\"\n    check2=$(find / -name '*.sh' -mtime -1)\ncheck21=$(find / -name '*.asp' -mtime -1)\ncheck22=$(find / -name '*.php' -mtime -1)\ncheck23=$(find / -name '*.aspx' -mtime -1)\ncheck24=$(find / -name '*.jsp' -mtime -1)\ncheck25=$(find / -name '*.html' -mtime -1)\ncheck26=$(find / -name '*.htm' -mtime -1)\ncheck9=$(find / -name core -exec ls -l {} \\;)\ncheck10=$(cat /etc/crontab)\ncheck12=$(ls -alt /usr/bin | head -10)\ncat <<eof\n\n############################查看所有被修改过的文件返回最近24小时内的############################\n${check2}\n${check21}\n${check22}\n${check23}\n${check24}\n${check25}\n${check26}\n${line}\n\n############################检查定时文件的完整性############################\n${check10}\n${line}\n\n############################查看系统命令是否被替换############################\n${check12}\n${line}\neof\n}\n\nfunction check(){\nversion\ngetsystemstatus\ngetcpustatus\ngetmemstatus\ngetdiskstatus\ngetnetworkstatus\ngetlistenstatus\ngetprocessstatus\ngetservicestatus\ngetautostartstatus\ngetloginstatus\ngetcronstatus\ngetuserstatus\ngetpasswordstatus\ngetsudoersstatus\ngetjdkstatus\ngetfirewallstatus\ngetsshstatus\ngetsyslogstatus\ngetsnmpstatus\ngetntpstatus\ngetinstalledstatus\ngetchage_file_24h\n}\n\n\n#执行检查并保存检查结果\ncheck > $resultfile\n\necho \"检查结果：$resultfile\"\necho -e \"`date \"+%y-%m-%d %h:%m:%s\"` host patrol inspection报告\"  | mail -a $resultfile -s \"host patrol inspection报告\" 1950974755@qq.com\n\nend\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n\n\n> 本文作者：许怀安\n> 创作时间：2022.02.12\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/02, 23:58:31",
      "lastUpdatedTimestamp": 1646236711000
    },
    {
      "title": "在线升级",
      "frontmatter": {
        "title": "在线升级",
        "date": "2022-03-01T09:21:54.000Z",
        "permalink": "/pages/42150c/",
        "categories": [
          "运维",
          "Centos内核升级"
        ],
        "tags": [
          "内核"
        ]
      },
      "regularPath": "/%E8%BF%90%E7%BB%B4/02.Centos%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/01.%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7.html",
      "relativePath": "运维/02.Centos内核升级/01.在线升级.md",
      "key": "v-cee7c8a8",
      "path": "/pages/42150c/",
      "headers": [
        {
          "level": 2,
          "title": "2.1 更新yum仓库",
          "slug": "_2-1-更新yum仓库",
          "normalizedTitle": "2.1 更新yum仓库",
          "charIndex": 183
        },
        {
          "level": 2,
          "title": "2.2 启用 ELRepo 仓库",
          "slug": "_2-2-启用-elrepo-仓库",
          "normalizedTitle": "2.2 启用 elrepo 仓库",
          "charIndex": 216
        },
        {
          "level": 3,
          "title": "2.2.1 导入ELRepo仓库的公共密钥",
          "slug": "_2-2-1-导入elrepo仓库的公共密钥",
          "normalizedTitle": "2.2.1 导入elrepo仓库的公共密钥",
          "charIndex": 404
        },
        {
          "level": 3,
          "title": "2.2.2 安装ELRepo仓库的yum源",
          "slug": "_2-2-2-安装elrepo仓库的yum源",
          "normalizedTitle": "2.2.2 安装elrepo仓库的yum源",
          "charIndex": 495
        },
        {
          "level": 2,
          "title": "2.3 查看可用的系统内核包",
          "slug": "_2-3-查看可用的系统内核包",
          "normalizedTitle": "2.3 查看可用的系统内核包",
          "charIndex": 601
        },
        {
          "level": 2,
          "title": "2.4 安装最新版本内核",
          "slug": "_2-4-安装最新版本内核",
          "normalizedTitle": "2.4 安装最新版本内核",
          "charIndex": 4493
        },
        {
          "level": 2,
          "title": "2.5 设置 grub2",
          "slug": "_2-5-设置-grub2",
          "normalizedTitle": "2.5 设置 grub2",
          "charIndex": 4628
        },
        {
          "level": 3,
          "title": "2.5.1 查看系统上的所有可用内核",
          "slug": "_2-5-1-查看系统上的所有可用内核",
          "normalizedTitle": "2.5.1 查看系统上的所有可用内核",
          "charIndex": 4673
        },
        {
          "level": 3,
          "title": "2.5.2 设置新的内核为grub2的默认版本",
          "slug": "_2-5-2-设置新的内核为grub2的默认版本",
          "normalizedTitle": "2.5.2 设置新的内核为grub2的默认版本",
          "charIndex": 5008
        },
        {
          "level": 3,
          "title": "2.5.3 生成 grub 配置文件并重启",
          "slug": "_2-5-3-生成-grub-配置文件并重启",
          "normalizedTitle": "2.5.3 生成 grub 配置文件并重启",
          "charIndex": 5583
        },
        {
          "level": 2,
          "title": "2.6 验证",
          "slug": "_2-6-验证",
          "normalizedTitle": "2.6 验证",
          "charIndex": 6264
        },
        {
          "level": 2,
          "title": "2.7 删除旧的内核（可选）",
          "slug": "_2-7-删除旧的内核-可选",
          "normalizedTitle": "2.7 删除旧的内核（可选）",
          "charIndex": 6323
        },
        {
          "level": 3,
          "title": "2.7.1 查看系统中全部的内核：",
          "slug": "_2-7-1-查看系统中全部的内核",
          "normalizedTitle": "2.7.1 查看系统中全部的内核：",
          "charIndex": 6342
        },
        {
          "level": 3,
          "title": "方法一：通过 删除",
          "slug": "方法一-通过-yum-remove删除",
          "normalizedTitle": "方法一：通过 删除",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "方法二：使用 工具删除",
          "slug": "方法二-使用-yum-utils工具删除",
          "normalizedTitle": "方法二：使用 工具删除",
          "charIndex": null
        }
      ],
      "headersStr": "2.1 更新yum仓库 2.2 启用 ELRepo 仓库 2.2.1 导入ELRepo仓库的公共密钥 2.2.2 安装ELRepo仓库的yum源 2.3 查看可用的系统内核包 2.4 安装最新版本内核 2.5 设置 grub2 2.5.1 查看系统上的所有可用内核 2.5.2 设置新的内核为grub2的默认版本 2.5.3 生成 grub 配置文件并重启 2.6 验证 2.7 删除旧的内核（可选） 2.7.1 查看系统中全部的内核： 方法一：通过 删除 方法二：使用 工具删除",
      "content": "# 在线升级\n\n注意\n\n本升级方法适用于所有Centos7.x系列的OS\n\n\n# 一、查看当前内核版本\n\nuname -a\n\n\n1\n\n\n3.10.0-514.el7.x86_64\n\n\n1\n\n\ncat /etc/redhat-release\n\n\n1\n\n\nCentOS Linux release 7.3.1611 (Core)\n\n\n1\n\n\n\n# 二、升级内核\n\n\n# 2.1 更新yum仓库\n\nyum update\n\n\n1\n\n\n\n# 2.2 启用 ELRepo 仓库\n\nELRepo 仓库是基于社区的用于企业级 Linux 仓库，提供对 RedHat Enterprise (RHEL) 和 其他基于 RHEL的 Linux 发行版（CentOS、Scientific、Fedora 等）的支持。 ELRepo 聚焦于和硬件相关的软件包，包括文件系统驱动、显卡驱动、网络驱动、声卡驱动和摄像头驱动等。\n\n\n# 2.2.1 导入ELRepo仓库的公共密钥\n\nrpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\n\n\n1\n\n\n\n# 2.2.2 安装ELRepo仓库的yum源\n\nrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\n\n\n1\n\n\n\n# 2.3 查看可用的系统内核包\n\nyum --disablerepo=\"*\" --enablerepo=\"elrepo-kernel\" list available\n\n\n1\n\n\nLoaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\n* elrepo-kernel: mirrors.tuna.tsinghua.edu.cn\n  elrepo-kernel                                                                                                                                                                 | 2.9 kB  00:00:00     \n  elrepo-kernel/primary_db                                                                                                                                                      | 1.8 MB  00:00:03     \n  Available Packages\n  kernel-lt.x86_64                                                                                  4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-devel.x86_64                                                                            4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-doc.noarch                                                                              4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-headers.x86_64                                                                          4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-tools.x86_64                                                                            4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-tools-libs.x86_64                                                                       4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-tools-libs-devel.x86_64                                                                 4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-ml.x86_64                                                                                  4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-devel.x86_64                                                                            4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-doc.noarch                                                                              4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-headers.x86_64                                                                          4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-tools.x86_64                                                                            4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-tools-libs.x86_64                                                                       4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-tools-libs-devel.x86_64                                                                 4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  perf.x86_64                                                                                       4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  python-perf.x86_64                                                                                4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 2.4 安装最新版本内核\n\nyum --enablerepo=elrepo-kernel install kernel-ml\n\n\n1\n\n\n--enablerepo 选项开启 CentOS 系统上的指定仓库。默认开启的是elrepo，这里用 -kernel 替换\n\n\n# 2.5 设置 grub2\n\n内核安装好后，需要设置为默认启动选项并重启后才会生效\n\n\n# 2.5.1 查看系统上的所有可用内核\n\nawk -F\\' '$1==\"menuentry \" {print i++ \" : \" $2}' /etc/grub2.cfg\n\n\n1\n\n\n0 : CentOS Linux (4.18.7-1.el7.elrepo.x86_64) 7 (Core)\n1 : CentOS Linux (3.10.0-862.11.6.el7.x86_64) 7 (Core)\n2 : CentOS Linux (3.10.0-514.el7.x86_64) 7 (Core)\n3 : CentOS Linux (0-rescue-063ec330caa04d4baae54c6902c62e54) 7 (Core)\n\n\n1\n2\n3\n4\n\n\n\n# 2.5.2 设置新的内核为grub2的默认版本\n\n服务器上存在4 个内核，我们要使用 4.18 这个版本，可以通过 grub2-set-default 0 命令或编辑 /etc/default/grub 文件来设置\n\n# 2.5.2.1 通过 grub2-set-default 0 命令设置\n\n其中 0 是上面查询出来的可用内核\n\ngrub2-set-default 0\n\n\n1\n\n\n# 2.5.2.2 方法2、编辑 /etc/default/grub 文件\n\n设置 GRUB_DEFAULT=0，通过上面查询显示的编号为 0 的内核作为默认内核：\n\nvim /etc/default/grub\n\n\n1\n\n\nGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"\nGRUB_DEFAULT=0\nGRUB_DISABLE_SUBMENU=true\nGRUB_TERMINAL_OUTPUT=\"console\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=cl/root rhgb quiet\"\nGRUB_DISABLE_RECOVERY=\"true\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.5.3 生成 grub 配置文件并重启\n\ngrub2-mkconfig -o /boot/grub2/grub.cfg\n\n\n1\n\n\nGenerating grub configuration file ...\nFound linux image: /boot/vmlinuz-4.18.7-1.el7.elrepo.x86_64\nFound initrd image: /boot/initramfs-4.18.7-1.el7.elrepo.x86_64.img\nFound linux image: /boot/vmlinuz-3.10.0-862.11.6.el7.x86_64\nFound initrd image: /boot/initramfs-3.10.0-862.11.6.el7.x86_64.img\nFound linux image: /boot/vmlinuz-3.10.0-514.el7.x86_64\nFound initrd image: /boot/initramfs-3.10.0-514.el7.x86_64.img\nFound linux image: /boot/vmlinuz-0-rescue-063ec330caa04d4baae54c6902c62e54\nFound initrd image: /boot/initramfs-0-rescue-063ec330caa04d4baae54c6902c62e54.img\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreboot\n\n\n1\n\n\n\n# 2.6 验证\n\nuname -r\n\n\n1\n\n\n4.18.7-1.el7.elrepo.x86_64\n\n\n1\n\n\n\n# 2.7 删除旧的内核（可选）\n\n\n# 2.7.1 查看系统中全部的内核：\n\nrpm -qa | grep kernel\n\n\n1\n\n\nkernel-3.10.0-514.el7.x86_64\nkernel-ml-4.18.7-1.el7.elrepo.x86_64\nkernel-tools-libs-3.10.0-862.11.6.el7.x86_64\nkernel-tools-3.10.0-862.11.6.el7.x86_64\nkernel-3.10.0-862.11.6.el7.x86_64\n\n\n1\n2\n3\n4\n5\n\n\n\n# 方法一：通过 yum remove删除\n\nyum remove kernel-3.10.0-514.el7.x86_64 \\\nkernel-ml-4.18.7-1.el7.elrepo.x86_64 \\\nkernel-tools-libs-3.10.0-862.11.6.el7.x86_64 \\\nkernel-tools-3.10.0-862.11.6.el7.x86_64 \\\nkernel-3.10.0-862.11.6.el7.x86_64\n\n\n1\n2\n3\n4\n5\n\n\n\n# 方法二：使用 yum-utils工具删除\n\n如果安装的内核不多于 3 个，yum-utils 工具不会删除任何一个。只有在安装的内核大于 3 个时，才会自动删除旧内核。\n\n安装yum-utils\n\nyum install yum-utils\n\n\n1\n\n\n删除旧版本\n\npackage-cleanup --oldkernels\n\n\n1\n\n\n> 本文作者：许怀安\n> 创作时间：2022.03.01\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# 在线升级\n\n注意\n\n本升级方法适用于所有centos7.x系列的os\n\n\n# 一、查看当前内核版本\n\nuname -a\n\n\n1\n\n\n3.10.0-514.el7.x86_64\n\n\n1\n\n\ncat /etc/redhat-release\n\n\n1\n\n\ncentos linux release 7.3.1611 (core)\n\n\n1\n\n\n\n# 二、升级内核\n\n\n# 2.1 更新yum仓库\n\nyum update\n\n\n1\n\n\n\n# 2.2 启用 elrepo 仓库\n\nelrepo 仓库是基于社区的用于企业级 linux 仓库，提供对 redhat enterprise (rhel) 和 其他基于 rhel的 linux 发行版（centos、scientific、fedora 等）的支持。 elrepo 聚焦于和硬件相关的软件包，包括文件系统驱动、显卡驱动、网络驱动、声卡驱动和摄像头驱动等。\n\n\n# 2.2.1 导入elrepo仓库的公共密钥\n\nrpm --import https://www.elrepo.org/rpm-gpg-key-elrepo.org\n\n\n1\n\n\n\n# 2.2.2 安装elrepo仓库的yum源\n\nrpm -uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\n\n\n1\n\n\n\n# 2.3 查看可用的系统内核包\n\nyum --disablerepo=\"*\" --enablerepo=\"elrepo-kernel\" list available\n\n\n1\n\n\nloaded plugins: fastestmirror\nloading mirror speeds from cached hostfile\n* elrepo-kernel: mirrors.tuna.tsinghua.edu.cn\n  elrepo-kernel                                                                                                                                                                 | 2.9 kb  00:00:00     \n  elrepo-kernel/primary_db                                                                                                                                                      | 1.8 mb  00:00:03     \n  available packages\n  kernel-lt.x86_64                                                                                  4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-devel.x86_64                                                                            4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-doc.noarch                                                                              4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-headers.x86_64                                                                          4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-tools.x86_64                                                                            4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-tools-libs.x86_64                                                                       4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-lt-tools-libs-devel.x86_64                                                                 4.4.155-1.el7.elrepo                                                                  elrepo-kernel\n  kernel-ml.x86_64                                                                                  4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-devel.x86_64                                                                            4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-doc.noarch                                                                              4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-headers.x86_64                                                                          4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-tools.x86_64                                                                            4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-tools-libs.x86_64                                                                       4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  kernel-ml-tools-libs-devel.x86_64                                                                 4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  perf.x86_64                                                                                       4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n  python-perf.x86_64                                                                                4.18.7-1.el7.elrepo                                                                   elrepo-kernel\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 2.4 安装最新版本内核\n\nyum --enablerepo=elrepo-kernel install kernel-ml\n\n\n1\n\n\n--enablerepo 选项开启 centos 系统上的指定仓库。默认开启的是elrepo，这里用 -kernel 替换\n\n\n# 2.5 设置 grub2\n\n内核安装好后，需要设置为默认启动选项并重启后才会生效\n\n\n# 2.5.1 查看系统上的所有可用内核\n\nawk -f\\' '$1==\"menuentry \" {print i++ \" : \" $2}' /etc/grub2.cfg\n\n\n1\n\n\n0 : centos linux (4.18.7-1.el7.elrepo.x86_64) 7 (core)\n1 : centos linux (3.10.0-862.11.6.el7.x86_64) 7 (core)\n2 : centos linux (3.10.0-514.el7.x86_64) 7 (core)\n3 : centos linux (0-rescue-063ec330caa04d4baae54c6902c62e54) 7 (core)\n\n\n1\n2\n3\n4\n\n\n\n# 2.5.2 设置新的内核为grub2的默认版本\n\n服务器上存在4 个内核，我们要使用 4.18 这个版本，可以通过 grub2-set-default 0 命令或编辑 /etc/default/grub 文件来设置\n\n# 2.5.2.1 通过 grub2-set-default 0 命令设置\n\n其中 0 是上面查询出来的可用内核\n\ngrub2-set-default 0\n\n\n1\n\n\n# 2.5.2.2 方法2、编辑 /etc/default/grub 文件\n\n设置 grub_default=0，通过上面查询显示的编号为 0 的内核作为默认内核：\n\nvim /etc/default/grub\n\n\n1\n\n\ngrub_timeout=5\ngrub_distributor=\"$(sed 's, release .*$,,g' /etc/system-release)\"\ngrub_default=0\ngrub_disable_submenu=true\ngrub_terminal_output=\"console\"\ngrub_cmdline_linux=\"crashkernel=auto rd.lvm.lv=cl/root rhgb quiet\"\ngrub_disable_recovery=\"true\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.5.3 生成 grub 配置文件并重启\n\ngrub2-mkconfig -o /boot/grub2/grub.cfg\n\n\n1\n\n\ngenerating grub configuration file ...\nfound linux image: /boot/vmlinuz-4.18.7-1.el7.elrepo.x86_64\nfound initrd image: /boot/initramfs-4.18.7-1.el7.elrepo.x86_64.img\nfound linux image: /boot/vmlinuz-3.10.0-862.11.6.el7.x86_64\nfound initrd image: /boot/initramfs-3.10.0-862.11.6.el7.x86_64.img\nfound linux image: /boot/vmlinuz-3.10.0-514.el7.x86_64\nfound initrd image: /boot/initramfs-3.10.0-514.el7.x86_64.img\nfound linux image: /boot/vmlinuz-0-rescue-063ec330caa04d4baae54c6902c62e54\nfound initrd image: /boot/initramfs-0-rescue-063ec330caa04d4baae54c6902c62e54.img\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreboot\n\n\n1\n\n\n\n# 2.6 验证\n\nuname -r\n\n\n1\n\n\n4.18.7-1.el7.elrepo.x86_64\n\n\n1\n\n\n\n# 2.7 删除旧的内核（可选）\n\n\n# 2.7.1 查看系统中全部的内核：\n\nrpm -qa | grep kernel\n\n\n1\n\n\nkernel-3.10.0-514.el7.x86_64\nkernel-ml-4.18.7-1.el7.elrepo.x86_64\nkernel-tools-libs-3.10.0-862.11.6.el7.x86_64\nkernel-tools-3.10.0-862.11.6.el7.x86_64\nkernel-3.10.0-862.11.6.el7.x86_64\n\n\n1\n2\n3\n4\n5\n\n\n\n# 方法一：通过 yum remove删除\n\nyum remove kernel-3.10.0-514.el7.x86_64 \\\nkernel-ml-4.18.7-1.el7.elrepo.x86_64 \\\nkernel-tools-libs-3.10.0-862.11.6.el7.x86_64 \\\nkernel-tools-3.10.0-862.11.6.el7.x86_64 \\\nkernel-3.10.0-862.11.6.el7.x86_64\n\n\n1\n2\n3\n4\n5\n\n\n\n# 方法二：使用 yum-utils工具删除\n\n如果安装的内核不多于 3 个，yum-utils 工具不会删除任何一个。只有在安装的内核大于 3 个时，才会自动删除旧内核。\n\n安装yum-utils\n\nyum install yum-utils\n\n\n1\n\n\n删除旧版本\n\npackage-cleanup --oldkernels\n\n\n1\n\n\n> 本文作者：许怀安\n> 创作时间：2022.03.01\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/13, 01:11:03",
      "lastUpdatedTimestamp": 1647105063000
    },
    {
      "title": "离线升级",
      "frontmatter": {
        "title": "离线升级",
        "date": "2022-03-01T09:22:10.000Z",
        "permalink": "/pages/79a802/",
        "categories": [
          "运维",
          "Centos内核升级"
        ],
        "tags": [
          "内核"
        ]
      },
      "regularPath": "/%E8%BF%90%E7%BB%B4/02.Centos%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/02.%E7%A6%BB%E7%BA%BF%E5%8D%87%E7%BA%A7.html",
      "relativePath": "运维/02.Centos内核升级/02.离线升级.md",
      "key": "v-1e97cebe",
      "path": "/pages/79a802/",
      "headers": [
        {
          "level": 2,
          "title": "一、获取离线升级包",
          "slug": "一、获取离线升级包",
          "normalizedTitle": "一、获取离线升级包",
          "charIndex": 11
        },
        {
          "level": 2,
          "title": "二、升级内核",
          "slug": "二、升级内核",
          "normalizedTitle": "二、升级内核",
          "charIndex": 291
        },
        {
          "level": 3,
          "title": "2.1 安装rpm包",
          "slug": "_2-1-安装rpm包",
          "normalizedTitle": "2.1 安装rpm包",
          "charIndex": 302
        },
        {
          "level": 3,
          "title": "2.2 查看系统上的所有可用内核",
          "slug": "_2-2-查看系统上的所有可用内核",
          "normalizedTitle": "2.2 查看系统上的所有可用内核",
          "charIndex": 437
        },
        {
          "level": 3,
          "title": "2.3 生成 grub 配置文件并重启",
          "slug": "_2-3-生成-grub-配置文件并重启",
          "normalizedTitle": "2.3 生成 grub 配置文件并重启",
          "charIndex": 1332
        },
        {
          "level": 2,
          "title": "2.4 验证",
          "slug": "_2-4-验证",
          "normalizedTitle": "2.4 验证",
          "charIndex": 2013
        },
        {
          "level": 2,
          "title": "2.5 删除旧的内核（可选）",
          "slug": "_2-5-删除旧的内核-可选",
          "normalizedTitle": "2.5 删除旧的内核（可选）",
          "charIndex": 2073
        },
        {
          "level": 3,
          "title": "2.5.1 查看系统中全部的内核：",
          "slug": "_2-5-1-查看系统中全部的内核",
          "normalizedTitle": "2.5.1 查看系统中全部的内核：",
          "charIndex": 2092
        }
      ],
      "headersStr": "一、获取离线升级包 二、升级内核 2.1 安装rpm包 2.2 查看系统上的所有可用内核 2.3 生成 grub 配置文件并重启 2.4 验证 2.5 删除旧的内核（可选） 2.5.1 查看系统中全部的内核：",
      "content": "# 离线升级\n\n\n# 一、获取离线升级包\n\n到elrepo的网站下载想要的版本\n\nwget https://elrepo.org/linux/kernel/el7/x86_64/RPMS/kernel-ml-5.16.10-1.el7.elrepo.x86_64.rpm\nwget https://elrepo.org/linux/kernel/el7/x86_64/RPMS/kernel-ml-devel-5.16.10-1.el7.elrepo.x86_64.rpm\n\n\n1\n2\n\n\n注意\n\n如果在目标服务器无法上网情况下也可在自己电脑下载rpm包，然后上传到服务器\n\n\n# 二、升级内核\n\n\n# 2.1 安装rpm包\n\nyum localinstall -y kernel-lt-4.4.206-1.el7.elrepo.x86_64.rpm \\\nkernel-lt-devel-4.4.206-1.el7.elrepo.x86_64.rpm\n\n\n1\n2\n\n\n\n# 2.2 查看系统上的所有可用内核\n\nawk -F\\' '$1==\"menuentry \" {print i++ \" : \" $2}' /etc/grub2.cfg\n\n\n1\n\n\n0 : CentOS Linux (5.16.10-1.el7.elrepo.x86_64) 7 (Core)\n1 : CentOS Linux (3.10.0-862.11.6.el7.x86_64) 7 (Core)\n2 : CentOS Linux (3.10.0-514.el7.x86_64) 7 (Core)\n3 : CentOS Linux (0-rescue-063ec330caa04d4baae54c6902c62e54) 7 (Core)\n\n\n1\n2\n3\n4\n\n\n设置新的内核为grub2的默认版本 服务器上存在4 个内核，我们要使用 5.16 这个版本，可以通过 grub2-set-default 0 命令或编辑 /etc/default/grub 文件来设置\n\n# 2.2.1 通过 grub2-set-default 0 命令设置\n\n其中 0 是上面查询出来的可用内核\n\ngrub2-set-default 0\n\n\n1\n\n\n# 2.2.2 方法2、编辑 /etc/default/grub 文件\n\n设置 GRUB_DEFAULT=0，通过上面查询显示的编号为 0 的内核作为默认内核：\n\nvim /etc/default/grub\n\n\n1\n\n\nGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"\nGRUB_DEFAULT=0\nGRUB_DISABLE_SUBMENU=true\nGRUB_TERMINAL_OUTPUT=\"console\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=cl/root rhgb quiet\"\nGRUB_DISABLE_RECOVERY=\"true\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.3 生成 grub 配置文件并重启\n\ngrub2-mkconfig -o /boot/grub2/grub.cfg\n\n\n1\n\n\nGenerating grub configuration file ...\nFound linux image: /boot/vmlinuz-5.16.10-1.el7.elrepo.x86_64\nFound initrd image: /boot/initramfs-5.16.10-1.el7.elrepo.x86_64.img\nFound linux image: /boot/vmlinuz-3.10.0-862.11.6.el7.x86_64\nFound initrd image: /boot/initramfs-3.10.0-862.11.6.el7.x86_64.img\nFound linux image: /boot/vmlinuz-3.10.0-514.el7.x86_64\nFound initrd image: /boot/initramfs-3.10.0-514.el7.x86_64.img\nFound linux image: /boot/vmlinuz-0-rescue-063ec330caa04d4baae54c6902c62e54\nFound initrd image: /boot/initramfs-0-rescue-063ec330caa04d4baae54c6902c62e54.img\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreboot\n\n\n1\n\n\n\n# 2.4 验证\n\nuname -r\n\n\n1\n\n\n5.16.10-1.el7.elrepo.x86_64\n\n\n1\n\n\n\n# 2.5 删除旧的内核（可选）\n\n\n# 2.5.1 查看系统中全部的内核：\n\nrpm -qa | grep kernel\n\n\n1\n\n\nkernel-3.10.0-514.el7.x86_64\nkernel-ml-5.16.10-1.el7.elrepo.x86_64\nkernel-tools-libs-3.10.0-862.11.6.el7.x86_64\nkernel-tools-3.10.0-862.11.6.el7.x86_64\nkernel-3.10.0-862.11.6.el7.x86_64\n\n\n1\n2\n3\n4\n5\n\n\n# 方法一：通过 yum remove删除\n\nyum remove kernel-3.10.0-514.el7.x86_64 \\\nkernel-tools-libs-3.10.0-862.11.6.el7.x86_64 \\\nkernel-tools-3.10.0-862.11.6.el7.x86_64 \\\nkernel-3.10.0-862.11.6.el7.x86_64\n\n\n1\n2\n3\n4\n\n\n# 方法二：使用 yum-utils工具删除\n\n如果安装的内核不多于 3 个，yum-utils 工具不会删除任何一个。只有在安装的内核大于 3 个时，才会自动删除旧内核。\n\n安装yum-utils\n\nyum install yum-utils\n\n\n1\n\n\n删除旧版本\n\npackage-cleanup --oldkernels\n\n\n1\n\n\n> 本文作者：许怀安\n> 创作时间：2022.03.01\n> 版权声明：本博客所有文章除特别声明外，均采用BY-NC-SA许可协议。转载请禀明出处！",
      "normalizedContent": "# 离线升级\n\n\n# 一、获取离线升级包\n\n到elrepo的网站下载想要的版本\n\nwget https://elrepo.org/linux/kernel/el7/x86_64/rpms/kernel-ml-5.16.10-1.el7.elrepo.x86_64.rpm\nwget https://elrepo.org/linux/kernel/el7/x86_64/rpms/kernel-ml-devel-5.16.10-1.el7.elrepo.x86_64.rpm\n\n\n1\n2\n\n\n注意\n\n如果在目标服务器无法上网情况下也可在自己电脑下载rpm包，然后上传到服务器\n\n\n# 二、升级内核\n\n\n# 2.1 安装rpm包\n\nyum localinstall -y kernel-lt-4.4.206-1.el7.elrepo.x86_64.rpm \\\nkernel-lt-devel-4.4.206-1.el7.elrepo.x86_64.rpm\n\n\n1\n2\n\n\n\n# 2.2 查看系统上的所有可用内核\n\nawk -f\\' '$1==\"menuentry \" {print i++ \" : \" $2}' /etc/grub2.cfg\n\n\n1\n\n\n0 : centos linux (5.16.10-1.el7.elrepo.x86_64) 7 (core)\n1 : centos linux (3.10.0-862.11.6.el7.x86_64) 7 (core)\n2 : centos linux (3.10.0-514.el7.x86_64) 7 (core)\n3 : centos linux (0-rescue-063ec330caa04d4baae54c6902c62e54) 7 (core)\n\n\n1\n2\n3\n4\n\n\n设置新的内核为grub2的默认版本 服务器上存在4 个内核，我们要使用 5.16 这个版本，可以通过 grub2-set-default 0 命令或编辑 /etc/default/grub 文件来设置\n\n# 2.2.1 通过 grub2-set-default 0 命令设置\n\n其中 0 是上面查询出来的可用内核\n\ngrub2-set-default 0\n\n\n1\n\n\n# 2.2.2 方法2、编辑 /etc/default/grub 文件\n\n设置 grub_default=0，通过上面查询显示的编号为 0 的内核作为默认内核：\n\nvim /etc/default/grub\n\n\n1\n\n\ngrub_timeout=5\ngrub_distributor=\"$(sed 's, release .*$,,g' /etc/system-release)\"\ngrub_default=0\ngrub_disable_submenu=true\ngrub_terminal_output=\"console\"\ngrub_cmdline_linux=\"crashkernel=auto rd.lvm.lv=cl/root rhgb quiet\"\ngrub_disable_recovery=\"true\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.3 生成 grub 配置文件并重启\n\ngrub2-mkconfig -o /boot/grub2/grub.cfg\n\n\n1\n\n\ngenerating grub configuration file ...\nfound linux image: /boot/vmlinuz-5.16.10-1.el7.elrepo.x86_64\nfound initrd image: /boot/initramfs-5.16.10-1.el7.elrepo.x86_64.img\nfound linux image: /boot/vmlinuz-3.10.0-862.11.6.el7.x86_64\nfound initrd image: /boot/initramfs-3.10.0-862.11.6.el7.x86_64.img\nfound linux image: /boot/vmlinuz-3.10.0-514.el7.x86_64\nfound initrd image: /boot/initramfs-3.10.0-514.el7.x86_64.img\nfound linux image: /boot/vmlinuz-0-rescue-063ec330caa04d4baae54c6902c62e54\nfound initrd image: /boot/initramfs-0-rescue-063ec330caa04d4baae54c6902c62e54.img\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreboot\n\n\n1\n\n\n\n# 2.4 验证\n\nuname -r\n\n\n1\n\n\n5.16.10-1.el7.elrepo.x86_64\n\n\n1\n\n\n\n# 2.5 删除旧的内核（可选）\n\n\n# 2.5.1 查看系统中全部的内核：\n\nrpm -qa | grep kernel\n\n\n1\n\n\nkernel-3.10.0-514.el7.x86_64\nkernel-ml-5.16.10-1.el7.elrepo.x86_64\nkernel-tools-libs-3.10.0-862.11.6.el7.x86_64\nkernel-tools-3.10.0-862.11.6.el7.x86_64\nkernel-3.10.0-862.11.6.el7.x86_64\n\n\n1\n2\n3\n4\n5\n\n\n# 方法一：通过 yum remove删除\n\nyum remove kernel-3.10.0-514.el7.x86_64 \\\nkernel-tools-libs-3.10.0-862.11.6.el7.x86_64 \\\nkernel-tools-3.10.0-862.11.6.el7.x86_64 \\\nkernel-3.10.0-862.11.6.el7.x86_64\n\n\n1\n2\n3\n4\n\n\n# 方法二：使用 yum-utils工具删除\n\n如果安装的内核不多于 3 个，yum-utils 工具不会删除任何一个。只有在安装的内核大于 3 个时，才会自动删除旧内核。\n\n安装yum-utils\n\nyum install yum-utils\n\n\n1\n\n\n删除旧版本\n\npackage-cleanup --oldkernels\n\n\n1\n\n\n> 本文作者：许怀安\n> 创作时间：2022.03.01\n> 版权声明：本博客所有文章除特别声明外，均采用by-nc-sa许可协议。转载请禀明出处！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/13, 01:11:03",
      "lastUpdatedTimestamp": 1647105063000
    }
  ],
  "themeConfig": {
    "blogInfo": {
      "blogCreate": "2020",
      "indexView": true,
      "pageView": true,
      "readingTime": true,
      "eachFileWords": [
        {
          "name": "RPC",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\Java\\01.gRPC笔记\\01.RPC.md",
          "wordsCount": "1.8k",
          "readingTime": "6.4m",
          "title": "RPC",
          "date": "2022-01-10T21:59:38.000Z",
          "permalink": "/pages/52d5c3",
          "article": "auto",
          "categories": [
            "gRPC笔记"
          ],
          "tags": [
            "gRPC",
            "Java"
          ]
        },
        {
          "name": "gRPC框架",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\Java\\01.gRPC笔记\\02.gRPC框架.md",
          "wordsCount": "1.2k",
          "readingTime": "4.6m",
          "title": "gRPC框架",
          "date": "2022-01-10T21:59:38.000Z",
          "permalink": "/pages/a2f161",
          "article": "auto",
          "categories": [
            "gRPC笔记"
          ],
          "tags": [
            "gRPC",
            "Java"
          ]
        },
        {
          "name": "Hello_gRPC",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\Java\\01.gRPC笔记\\03.Hello_gRPC.md",
          "wordsCount": "1.7k",
          "readingTime": "8.2m",
          "title": "Hello gRPC",
          "date": "2022-01-10T21:59:38.000Z",
          "permalink": "/pages/793dcb",
          "article": "auto",
          "categories": [
            "gRPC笔记"
          ],
          "tags": [
            "gRPC",
            "Java"
          ]
        },
        {
          "name": "gRPC_Bug",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\Java\\01.gRPC笔记\\04.gRPC_Bug.md",
          "wordsCount": 319,
          "readingTime": "1.6m",
          "title": "gRPC Bug记录",
          "date": "2021-01-10T21:59:38.000Z",
          "permalink": "/pages/2f674a",
          "article": "auto",
          "categories": [
            "gRPC笔记"
          ],
          "tags": [
            "gRPC",
            "Java"
          ]
        },
        {
          "name": "HuTool",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\Java\\02.HuTool笔记\\01.HuTool.md",
          "wordsCount": 848,
          "readingTime": "3.4m",
          "title": "HuTool",
          "date": "2022-01-26T20:56:49.000Z",
          "permalink": "/pages/5fedc1/",
          "categories": [
            "Java",
            "HuTool笔记"
          ],
          "tags": [
            "Java"
          ]
        },
        {
          "name": "Hutoo组件",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\Java\\02.HuTool笔记\\02.Hutoo组件.md",
          "wordsCount": "1.4k",
          "readingTime": "5.4m",
          "title": "Hutoo组件",
          "date": "2022-01-26T21:23:53.000Z",
          "permalink": "/pages/f83d9d/",
          "categories": [
            "Java",
            "HuTool笔记"
          ],
          "tags": [
            "Java"
          ]
        },
        {
          "name": "使用systemctl命令管理部署Java jar包",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\Java\\03.其他\\01.使用systemctl命令管理部署Java jar包.md",
          "wordsCount": 873,
          "readingTime": "3.6m",
          "title": "使用systemctl命令管理部署Java jar包",
          "date": "2022-02-18T18:05:16.000Z",
          "permalink": "/pages/82aec0/",
          "categories": [
            "Java",
            "其他"
          ],
          "tags": [
            "scripts"
          ]
        },
        {
          "name": "关于我",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\Other\\01.关于我.md",
          "wordsCount": 465,
          "readingTime": "1.7m",
          "title": "关于我",
          "date": "2020-12-16T00:00:00.000Z",
          "permalink": "/pages/db78e2",
          "article": "auto",
          "categories": [
            "Other"
          ],
          "tags": [
            null
          ]
        },
        {
          "name": "windows",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\其他\\01.环境搭建\\01.windows.md",
          "wordsCount": "1.8k",
          "readingTime": "7m",
          "title": "Windows下Java开发环境搭建",
          "date": "2021-12-15T10:11:38.000Z",
          "permalink": "/pages/a32ce8",
          "article": "auto",
          "categories": [
            "Java"
          ],
          "tags": [
            "Java"
          ]
        },
        {
          "name": "linux",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\其他\\01.环境搭建\\02.linux.md",
          "wordsCount": 468,
          "readingTime": "2m",
          "title": "Linux下Java运行环境搭建",
          "date": "2021-12-15T10:11:38.000Z",
          "permalink": "/pages/f22bdb",
          "article": "auto",
          "categories": [
            "Java"
          ],
          "tags": [
            "Java"
          ]
        },
        {
          "name": "博客搭建",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\其他\\02.博客搭建\\01.博客搭建.md",
          "wordsCount": "2.5k",
          "readingTime": "10.6m",
          "title": "VuePress-Vdoing搭建个人博客",
          "sidebar": "auto",
          "date": "2022-01-24T01:04:14.000Z",
          "permalink": "/pages/0737a0/",
          "categories": [
            "博客搭建"
          ],
          "tags": [
            null
          ]
        },
        {
          "name": "微信云托管部署Vuepress",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\其他\\02.博客搭建\\02.微信云托管部署Vuepress.md",
          "wordsCount": "1.4k",
          "readingTime": "4.9m",
          "title": "微信云托管部署Vuepress",
          "date": "2022-03-13T00:24:27.000Z",
          "permalink": "/pages/c21fef/",
          "categories": [
            "其他",
            "博客搭建"
          ],
          "tags": [
            null
          ]
        },
        {
          "name": "Nginx报错403",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\其他\\03.踩坑记录\\01.Nginx报错403.md",
          "wordsCount": 542,
          "readingTime": "2.3m",
          "title": "Nginx报错403",
          "date": "2022-03-02T23:26:11.000Z",
          "permalink": "/pages/9c7c7b/",
          "categories": [
            "其他",
            "踩坑记录"
          ],
          "tags": [
            "Nginx"
          ]
        },
        {
          "name": "Linux下病毒排杀过程",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\运维\\01.Linux\\01.Linux下病毒排杀过程.md",
          "wordsCount": "1.8k",
          "readingTime": "7.7m",
          "title": "Linux下病毒排杀过程",
          "date": "2021-11-05T20:23:51.000Z",
          "permalink": "/pages/af9ce4/",
          "categories": [
            "运维",
            "Linux"
          ],
          "tags": [
            "运维",
            "Linux",
            "安全"
          ]
        },
        {
          "name": "Linux主机巡检脚本",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\运维\\01.Linux\\02.Linux主机巡检脚本.md",
          "wordsCount": "3.3k",
          "readingTime": "17.5m",
          "title": "Linux主机巡检脚本",
          "date": "2022-02-12T13:42:18.000Z",
          "permalink": "/pages/11d270/",
          "categories": [
            "运维",
            "Linux"
          ],
          "tags": [
            "运维",
            "Linux",
            "主机巡检"
          ]
        },
        {
          "name": "在线升级",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\运维\\02.Centos内核升级\\01.在线升级.md",
          "wordsCount": "1.2k",
          "readingTime": "6.4m",
          "title": "在线升级",
          "date": "2022-03-01T09:21:54.000Z",
          "permalink": "/pages/42150c/",
          "categories": [
            "运维",
            "Centos内核升级"
          ],
          "tags": [
            "内核"
          ]
        },
        {
          "name": "离线升级",
          "filePath": "E:\\vuepress-vdoing-blog\\docs\\运维\\02.Centos内核升级\\02.离线升级.md",
          "wordsCount": 825,
          "readingTime": "4.2m",
          "title": "离线升级",
          "date": "2022-03-01T09:22:10.000Z",
          "permalink": "/pages/79a802/",
          "categories": [
            "运维",
            "Centos内核升级"
          ],
          "tags": [
            "内核"
          ]
        }
      ],
      "mdFileCountType": "archives",
      "totalWords": "archives",
      "moutedEvent": ".tags-wrapper",
      "indexIteration": 2500,
      "pageIteration": 2500
    },
    "nav": [
      {
        "text": "首页",
        "link": "/"
      },
      {
        "text": "Java",
        "items": [
          {
            "text": "gRP笔记",
            "items": [
              {
                "text": "RPC",
                "link": "/pages/52d5c3/"
              },
              {
                "text": "gRPC",
                "link": "/pages/a2f161/"
              },
              {
                "text": "Hello gRPC",
                "link": "/pages/793dcb/"
              },
              {
                "text": "gRPC Bug",
                "link": "/pages/2f674a/"
              }
            ]
          },
          {
            "text": "HuTool笔记",
            "items": [
              {
                "text": "HuTool",
                "link": "/pages/5fedc1/"
              },
              {
                "text": "HuTool组件",
                "link": "/pages/f83d9d/"
              }
            ]
          },
          {
            "text": "其他",
            "items": [
              {
                "text": "使用systemctl命令管理部署Java jar包",
                "link": "/pages/82aec0/"
              }
            ]
          }
        ]
      },
      {
        "text": "运维",
        "items": [
          {
            "text": "Linux",
            "items": [
              {
                "text": "Linux下挖矿病毒排杀过程",
                "link": "/pages/af9ce4/"
              },
              {
                "text": "Linux主机巡检脚本",
                "link": "/pages/11d270/"
              }
            ]
          },
          {
            "text": "Centos内核升级",
            "items": [
              {
                "text": "在线升级",
                "link": "/pages/42150c/"
              },
              {
                "text": "离线升级",
                "link": "/pages/79a802/"
              }
            ]
          }
        ]
      },
      {
        "text": "其他",
        "items": [
          {
            "text": "环境搭建",
            "items": [
              {
                "text": "Windows下Java开发环境搭建",
                "link": "/pages/a32ce8/"
              },
              {
                "text": "Linux下Java运行环境搭建",
                "link": "/pages/f22bdb/"
              }
            ]
          },
          {
            "text": "博客搭建",
            "items": [
              {
                "text": "Vuepress搭建博客",
                "link": "/pages/0737a0/"
              },
              {
                "text": "微信云托管部署Vuepress",
                "link": "/pages/c21fef/"
              }
            ]
          },
          {
            "text": "踩坑记录",
            "items": [
              {
                "text": "Nginx报错403",
                "link": "/pages/9c7c7b/"
              }
            ]
          }
        ]
      },
      {
        "text": "关于我",
        "link": "/pages/db78e2/"
      },
      {
        "text": "Gitee",
        "link": "https://gitee.com/keington/"
      },
      {
        "text": "Github",
        "link": "https://github.com/keington/"
      }
    ],
    "sidebarDepth": 2,
    "logo": "/images/logo.jpg",
    "searchMaxSuggestions": 10,
    "lastUpdated": "上次更新",
    "sidebar": {
      "/Java/": [
        {
          "title": "gRPC笔记",
          "collapsable": false,
          "children": [
            [
              "01.gRPC笔记/01.RPC.md",
              "RPC",
              "/pages/52d5c3"
            ],
            [
              "01.gRPC笔记/02.gRPC框架.md",
              "gRPC框架",
              "/pages/a2f161"
            ],
            [
              "01.gRPC笔记/03.Hello_gRPC.md",
              "Hello gRPC",
              "/pages/793dcb"
            ],
            [
              "01.gRPC笔记/04.gRPC_Bug.md",
              "gRPC Bug记录",
              "/pages/2f674a"
            ]
          ]
        },
        {
          "title": "HuTool笔记",
          "collapsable": false,
          "children": [
            [
              "02.HuTool笔记/01.HuTool.md",
              "HuTool",
              "/pages/5fedc1/"
            ],
            [
              "02.HuTool笔记/02.Hutoo组件.md",
              "Hutoo组件",
              "/pages/f83d9d/"
            ]
          ]
        },
        {
          "title": "其他",
          "collapsable": false,
          "children": [
            [
              "03.其他/01.使用systemctl命令管理部署Java jar包.md",
              "使用systemctl命令管理部署Java jar包",
              "/pages/82aec0/"
            ]
          ]
        }
      ],
      "catalogue": {},
      "/Other/": [
        [
          "01.关于我.md",
          "关于我",
          "/pages/db78e2"
        ]
      ],
      "/其他/": [
        {
          "title": "环境搭建",
          "collapsable": false,
          "children": [
            [
              "01.环境搭建/01.windows.md",
              "Windows下Java开发环境搭建",
              "/pages/a32ce8"
            ],
            [
              "01.环境搭建/02.linux.md",
              "Linux下Java运行环境搭建",
              "/pages/f22bdb"
            ]
          ]
        },
        {
          "title": "博客搭建",
          "collapsable": false,
          "children": [
            [
              "02.博客搭建/01.博客搭建.md",
              "VuePress-Vdoing搭建个人博客",
              "/pages/0737a0/"
            ],
            [
              "02.博客搭建/02.微信云托管部署Vuepress.md",
              "微信云托管部署Vuepress",
              "/pages/c21fef/"
            ]
          ]
        },
        {
          "title": "踩坑记录",
          "collapsable": false,
          "children": [
            [
              "03.踩坑记录/01.Nginx报错403.md",
              "Nginx报错403",
              "/pages/9c7c7b/"
            ]
          ]
        }
      ],
      "/运维/": [
        {
          "title": "Linux",
          "collapsable": false,
          "children": [
            [
              "01.Linux/01.Linux下病毒排杀过程.md",
              "Linux下病毒排杀过程",
              "/pages/af9ce4/"
            ],
            [
              "01.Linux/02.Linux主机巡检脚本.md",
              "Linux主机巡检脚本",
              "/pages/11d270/"
            ]
          ]
        },
        {
          "title": "Centos内核升级",
          "collapsable": false,
          "children": [
            [
              "02.Centos内核升级/01.在线升级.md",
              "在线升级",
              "/pages/42150c/"
            ],
            [
              "02.Centos内核升级/02.离线升级.md",
              "离线升级",
              "/pages/79a802/"
            ]
          ]
        }
      ]
    },
    "sidebarOpen": true,
    "updateBar": {
      "showToArticle": false,
      "moreArticle": "/archives"
    },
    "category": true,
    "tag": true,
    "archive": false,
    "author": {
      "name": "许怀安",
      "link": "https://github.com/keington"
    },
    "blogger": {
      "avatar": "/images/logo.jpg",
      "name": "许怀安",
      "slogan": "所思，所学，所想，所行"
    },
    "social": {
      "iconfontCssFile": "https://at.alicdn.com/t/font_1678482_4tbhmh589x.css",
      "icons": [
        {
          "iconClass": "icon-youjian",
          "title": "Email",
          "link": "mailto:keington@outlook.com"
        },
        {
          "iconClass": "icon-QQ",
          "title": "QQ",
          "link": "tencent://message/?uin=qq1950974755&Site=Sambow&Menu=yes"
        },
        {
          "iconClass": "icon-github",
          "title": "Github",
          "link": "https://github.com/keington/"
        },
        {
          "iconClass": "icon-gitee",
          "title": "Gitee",
          "link": "https://gitee.com/keington/"
        }
      ]
    },
    "footer": {
      "createYear": 2020,
      "copyrightInfo": "许怀安 | MIT License <br> <a target=\"_blank\" href=\"http://beian.miit.gov.cn/\" >青ICP备2022000072号-1</a><a target=\"_blank\" href=\"http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=63010302000386\" > | 青公网安备 63010302000386号</a>"
    },
    "htmlModules": {
      "pageB": "\n  <div class=\"wwads-cn wwads-horizontal pageB\" data-id=\"136\" style=\"width:100%;max-height:80px;min-height:auto;\"></div>\n  <style>\n    .pageB img{width:80px!important;}\n    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{line-height:1;}\n  </style>\n  ",
      "windowRB": "\n    <div class=\"wwads-cn wwads-vertical windowRB\" data-id=\"136\" style=\"max-width:160px;\n    min-width: auto;min-height:auto;\"></div>\n    <style>\n      .windowRB{ padding: 0;}\n      .windowRB .wwads-img{margin-top: 10px;}\n      .windowRB .wwads-content{margin: 0 10px 10px 10px;}\n      .custom-html-window-rb .close-but{\n        display: none;\n      }\n    </style>\n  "
    }
  }
}